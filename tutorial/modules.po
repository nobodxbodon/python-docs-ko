# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/modules.rst:5
msgid "Modules"
msgstr "모듈"

#: ../Doc/tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the "
"definitions you have made (functions and variables) are lost. Therefore, "
"if you want to write a somewhat longer program, you are better off using "
"a text editor to prepare the input for the interpreter and running it "
"with that file as input instead.  This is known as creating a *script*.  "
"As your program gets longer, you may want to split it into several files "
"for easier maintenance.  You may also want to use a handy function that "
"you've written in several programs without copying its definition into "
"each program."
msgstr ""
"파이썬 인터프리터를 종료한 후에 다시 들어가면, 여러분이 만들었던 정의들이 사라진다 (함수나 변수들). "
"그래서, 좀 긴 프로그램을 쓰고자 한다면, 대신 인터프리터에 줄 입력을 편집기를 사용해서 준비한 후에 그 "
"파일을 입력으로 사용해서 실행하는 것이 좋다. 이렇게 하는 것을 *스크립트* 를 만든다고 한다. "
"프로그램이 길어짐에 따라, 유지를 쉽게 하려고 여러 개의 파일로 나누고 싶을 수 있다. 여러 "
"프로그램에서 썼던 편리한 함수를 각 프로그램에 정의를 복사하지 않고도 사용하고 싶을 수도 있다."

#: ../Doc/tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use "
"them in a script or in an interactive instance of the interpreter. Such a"
" file is called a *module*; definitions from a module can be *imported* "
"into other modules or into the *main* module (the collection of variables"
" that you have access to in a script executed at the top level and in "
"calculator mode)."
msgstr ""
"이런 것을 지원하기 위해, 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 "
"수 있는 방법을 제공한다. 그런 파일을 *모듈* 이라고 부른다; 모듈로부터 정의들이 다른 모듈이나 *메인* "
"모듈로 *임포트* 될 수 있다 (메인 모듈은 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 "
"액세스하는 변수들의 컬렉션이다)."

#: ../Doc/tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The "
"file name is the module name with the suffix :file:`.py` appended.  "
"Within a module, the module's name (as a string) is available as the "
"value of the global variable ``__name__``.  For instance, use your "
"favorite text editor to create a file called :file:`fibo.py` in the "
"current directory with the following contents::"
msgstr ""
"모듈은 파이썬 정의와 문장들을 담고 있는 파일이다. 파일의 이름은 모듈 이름에 확장자 "
":file:`.py` 를 붙인다. 모듈 내에서, 모듈의 이름은 전역 변수 ``__name__`` 으로 제공된다. "
"예를 들어, 여러분이 좋아하는 편집기로 :file:`fibo.py` 라는 이름의 파일을 현재 디렉터리에 "
"만들고 다음과 같은 내용으로 채운다::"

#: ../Doc/tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the "
"following command::"
msgstr ""
"이제 파이썬 인터프리터에 들어가서 이 모듈을 다음과 같은 명령으로 임포트 한다::"

#: ../Doc/tutorial/modules.rst:50
msgid ""
"This does not enter the names of the functions defined in ``fibo``  "
"directly in the current symbol table; it only enters the module name "
"``fibo`` there. Using the module name you can access the functions::"
msgstr ""
"이렇게 한다고 ``fibo`` 에 정의된 함수들의 이름이 현재 심볼 테이블에 직접 들어가지는 않는다; "
"오직 모듈 이름 ``fibo`` 만 들어갈 뿐이다. 이 모듈 이름을 사용해서 함수들을 액세스할 수 있다::"

#: ../Doc/tutorial/modules.rst:61
msgid "If you intend to use a function often you can assign it to a local name::"
msgstr "함수를 자주 사용할 거라면 지역 이름으로 대입할 수 있다::"

#: ../Doc/tutorial/modules.rst:71
msgid "More on Modules"
msgstr "모듈 더 보기"

#: ../Doc/tutorial/modules.rst:73
msgid ""
"A module can contain executable statements as well as function "
"definitions. These statements are intended to initialize the module. They"
" are executed only the *first* time the module name is encountered in an "
"import statement. [#]_ (They are also run if the file is executed as a "
"script.)"
msgstr ""
"모듈은 함수 정의뿐만 아니라 실행 가능한 문장들도 포함할 수 있다. 이 문장들은 모듈을 초기화하는 데 "
"사용된다. 이것들은 임포트 문에서 모듈 이름이 *처음* 등장할 때만 실행된다. [#]_ (이것들은 "
"파일이 스크립트로 실행될 때도 실행된다.)"

#: ../Doc/tutorial/modules.rst:78
msgid ""
"Each module has its own private symbol table, which is used as the global"
" symbol table by all functions defined in the module. Thus, the author of"
" a module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if "
"you know what you are doing you can touch a module's global variables "
"with the same notation used to refer to its functions, "
"``modname.itemname``."
msgstr ""
"각 모듈은 자신만의 심볼 테이블을 갖고 있는데, 그 모듈에서 정의된 함수들의 전역 심볼 테이블로 "
"사용된다. 그래서, 모듈의 저자는 사용자의 전역 변수와 우연히 충돌할 것을 걱정하지 않고 전역 변수를 "
"사용할 수 있다. 반면에, 여러분이 무얼 하는지 안다면, 모듈의 함수를 참조하는데 사용된 것과 같은 "
"표기법으로 모듈의 전역 변수들을 건드릴 수 있다, ``modname.itemname``."

#: ../Doc/tutorial/modules.rst:85
msgid ""
"Modules can import other modules.  It is customary but not required to "
"place all :keyword:`import` statements at the beginning of a module (or "
"script, for that matter).  The imported module names are placed in the "
"importing module's global symbol table."
msgstr ""
"모듈은 다른 모듈들을 임포트할 수 있다. 모든 :keyword:`import` 문들을 모듈의 처음에 놓는 것이 "
"관례지만 반드시 그래야 하는 것은 아니다 (그 점에 관한 한 스크립트도 마찬가지다). 임포트되는 모듈 이름은 "
"임포트하는 모듈의 전역 심볼 테이블에 들어간다."

#: ../Doc/tutorial/modules.rst:90
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
"모듈에 들어있는 이름들을 직접 임포트하는 모듈의 심볼 테이블로 임포트하는 :keyword:`import` "
"문의 변종이 있다. 예를 들어::"

#: ../Doc/tutorial/modules.rst:97
msgid ""
"This does not introduce the module name from which the imports are taken "
"in the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr ""
"이것은 지역 심볼 테이블에 임포트되는 모듈의 이름을 만들지 않는다 (그래서 이 예에서는, "
"``fibo`` 가 정의되지 않는다)."

#: ../Doc/tutorial/modules.rst:100
msgid "There is even a variant to import all names that a module defines::"
msgstr "모듈이 정의하는 모든 이름을 임포트하는 변종도 있다::"

#: ../Doc/tutorial/modules.rst:106
msgid ""
"This imports all names except those beginning with an underscore (``_``)."
" In most cases Python programmers do not use this facility since it "
"introduces an unknown set of names into the interpreter, possibly hiding "
"some things you have already defined."
msgstr ""
"이것은 밑줄 (``_``) 로 시작하는 것들을 제외한 모든 이름을 임포트 한다. 대부분 파이썬 "
"프로그래머들은 이 기능을 사용하지 않는데, 인터프리터로 알려지지 않은 이름들의 집합을 도입하게 되어, "
"여러분이 이미 정의한 것들을 가리게 될 수 있기 때문이다."

#: ../Doc/tutorial/modules.rst:111
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"일반적으로 모듈이나 패키지에서 ``*`` 를 임포트하는 것은 눈살을 찌푸리게 한다는 것에 유의해야 "
"하는데, 종종 읽기에 편하지 않은 코드를 만들기 때문이다. 하지만, 대화형 세션에서 입력을 줄이고자 "
"사용하는 것은 상관없다."

#: ../Doc/tutorial/modules.rst:117
msgid ""
"For efficiency reasons, each module is only imported once per interpreter"
" session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test "
"interactively, use :func:`importlib.reload`, e.g. ``import importlib; "
"importlib.reload(modulename)``."
msgstr ""
"효율성의 이유로, 각 모듈은 인터프리터 세션마다 한 번만 임포트된다. 그래서, 여러분이 모듈을 수정하면, "
"인터프리터를 다시 시작시켜야 한다 --- 또는, 대화형으로 시험하는 모듈이 하나뿐이라면, "
":func:`importlib.reload` 를 사용한다. 예를 들어, "
"``import importlib; importlib.reload(modulename)``."

#: ../Doc/tutorial/modules.rst:127
msgid "Executing modules as scripts"
msgstr "모듈을 스크립트로 실행하기"

#: ../Doc/tutorial/modules.rst:129
msgid "When you run a Python module with ::"
msgstr "여러분이 파이썬 모듈을 이렇게 실행하면 ::"

#: ../Doc/tutorial/modules.rst:133
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding"
" this code at the end of your module::"
msgstr ""
"모듈에 있는 코드는, 그것을 임포트할 때처럼 실행된다. 하지만 ``__name__`` 은 "
"``\"__main__\"`` 로 설정된다. 이것은, 이 코드를 모듈의 끝에 붙여서::"

#: ../Doc/tutorial/modules.rst:141
msgid ""
"you can make the file usable as a script as well as an importable module,"
" because the code that parses the command line only runs if the module is"
" executed as the \"main\" file:"
msgstr ""
"파일을 임포트할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 있음을 의미하는데, "
"오직 모듈이 \"메인\" 파일로 실행될 때만 명령행을 파싱하는 코드가 실행되기 때문이다:"

#: ../Doc/tutorial/modules.rst:150
msgid "If the module is imported, the code is not run::"
msgstr "모듈이 임포트될 때, 코드는 실행되지 않는다::"

#: ../Doc/tutorial/modules.rst:155
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes "
"a test suite)."
msgstr ""
"이것은 종종 모듈에 대한 편리한 사용자 인터페이스를 제공하거나 테스트 목적으로 사용된다 (모듈을 "
"스크립트로 실행하면 테스트 스위트를 실행한다)."

#: ../Doc/tutorial/modules.rst:162
msgid "The Module Search Path"
msgstr "모듈 검색 경로"

#: ../Doc/tutorial/modules.rst:166
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first "
"searches for a built-in module with that name. If not found, it then "
"searches for a file named :file:`spam.py` in a list of directories given "
"by the variable :data:`sys.path`.  :data:`sys.path` is initialized from "
"these locations:"
msgstr ""
":mod:`spam` 이라는 이름의 모듈이 임포트될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾는다. 발견되지 않으면, 변수 :data:`sys.path` 로 주어지는 디렉터리들에서 :file:`spam.py` 라는 이름의 파일을 찾는다. :data:`sys.path` 는 이 위치들로 초기화된다:"

#: ../Doc/tutorial/modules.rst:171
msgid ""
"The directory containing the input script (or the current directory when "
"no file is specified)."
msgstr ""
"입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 현재 디렉터리)."

#: ../Doc/tutorial/modules.rst:173
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as "
"the shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (디렉터리 이름들의 목록, 셸 변수 :envvar:`PATH` 와 같은 문법)."

#: ../Doc/tutorial/modules.rst:175
msgid "The installation-dependent default."
msgstr "설치 의존적인 기본값"

#: ../Doc/tutorial/modules.rst:178
msgid ""
"On file systems which support symlinks, the directory containing the "
"input script is calculated after the symlink is followed. In other words "
"the directory containing the symlink is **not** added to the module "
"search path."
msgstr ""
"심볼릭 링크를 지원하는 파일 시스템에서, 입력 스크립트를 포함하는 디렉터리는 심볼릭 링크를 변환한 "
"후에 계산된다. 다른 말로, 심볼릭 링크를 포함하는 디렉터리는 모듈 검색 경로에 포함되지 **않는다**."

#: ../Doc/tutorial/modules.rst:182
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of "
"the search path, ahead of the standard library path. This means that "
"scripts in that directory will be loaded instead of modules of the same "
"name in the library directory. This is an error unless the replacement is"
" intended.  See section :ref:`tut-standardmodules` for more information."
msgstr ""
"초기화 후에, 파이썬 프로그램은 :data:`sys.path` 를 수정할 수 있다. 스크립트를 포함하는 "
"디렉터리는 검색 경로의 처음에, 표준 라이브러리 경로의 앞에 놓인다. 이것은 같은 이름일 경우 "
"라이브러리 디렉터리에 있는 것 대신 스크립트를 포함하는 디렉터리의 것이 로드된다는 뜻이다. 이 치환이 "
"의도된 것이 아니라면 에러다. 더 자세한 정보는 :ref:`tut-standardmodules` 에 나온다."

#: ../Doc/tutorial/modules.rst:193
msgid "\"Compiled\" Python files"
msgstr "\"컴파일된\" 파이썬 파일"

#: ../Doc/tutorial/modules.rst:195
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name "
":file:`module.{version}.pyc`, where the version encodes the format of the"
" compiled file; it generally contains the Python version number.  For "
"example, in CPython release 3.3 the compiled version of spam.py would be "
"cached as ``__pycache__/spam.cpython-33.pyc``.  This naming convention "
"allows compiled modules from different releases and different versions of"
" Python to coexist."
msgstr ""
"모듈 로딩을 빠르게 하려고, 파이썬은 ``__pycache__`` 디렉터리에 각 모듈의 컴파일된 버전을 "
":file:`module.{version}.pyc` 라는 이름으로 캐싱한다. version 은 컴파일된 파일의 형식을 "
"지정한다; 일반적으로 파이썬의 버전 번호를 포함한다. 예를 들어, CPython 배포 3.3 에서 spam.py "
"의 컴파일된 버전은 ``__pycache__/spam.cpython-33.pyc`` 로 캐싱 된다. 이 명명법은 서로 다른 "
"파이썬 배포와 버전의 컴파일된 모듈들이 공존할 수 있도록 한다."

#: ../Doc/tutorial/modules.rst:203
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a"
" completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with "
"different architectures."
msgstr ""
"파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 컴파일해야 하는지 검사한다. "
"이것은 완전히 자동화된 과정이다. 또한, 컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 "
"서로 다른 아키텍처를 갖는 시스템들에서 공유할 수 있다."

#: ../Doc/tutorial/modules.rst:208
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and "
"there must not be a source module."
msgstr ""
"파이썬은 두 가지 상황에서 캐시를 검사하지 않는다. 첫째로, 명령행에서 직접 로드되는 모듈들은 항상 "
"재컴파일하고 그 결과를 저장하지 않는다. 둘째로, 소스 모듈이 없으면 캐시를 검사하지 않는다. 소스 "
"없는 (컴파일된 파일만 있는) 배포를 지원하려면, 컴파일된 모듈이 소스 디렉터리에 있어야 하고, 소스 "
"모듈이 없어야 한다."

#: ../Doc/tutorial/modules.rst:215
msgid "Some tips for experts:"
msgstr "전문가를 위한 몇 가지 팁"

#: ../Doc/tutorial/modules.rst:217
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python "
"command to reduce the size of a compiled module.  The ``-O`` switch "
"removes assert statements, the ``-OO`` switch removes both assert "
"statements and __doc__ strings.  Since some programs may rely on having "
"these available, you should only use this option if you know what you're "
"doing.  \"Optimized\" modules have an ``opt-`` tag and are usually "
"smaller.  Future releases may change the effects of optimization."
msgstr ""
"컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 :option:`-O` 나 :option:`-OO` 스위치를 사용할 "
"수 있다. ``-O`` 스위치는 assert 문을 제거하고, ``-OO`` 스위치는 assert 문과 __doc__ "
"문자열을 모두 제거한다. 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 하고 있는지 아는 경우만 이 "
"옵션을 사용해야 한다. \"최적화된\" 모듈은 ``opt-`` 태그를 갖고, 보통 더 작다. 미래의 배포에서는 "
"최적화의 효과가 변경될 수 있다."

#: ../Doc/tutorial/modules.rst:225
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file "
"than when it is read from a ``.py`` file; the only thing that's faster "
"about ``.pyc`` files is the speed with which they are loaded."
msgstr ""
"``.py`` 파일에서 읽을 때보다 ``.pyc`` 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 않는다; "
"``.pyc`` 파일에서 더 빨라지는 것은 로드되는 속도뿐이다."

#: ../Doc/tutorial/modules.rst:229
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"모듈 :mod:`compileall` 은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있다."

#: ../Doc/tutorial/modules.rst:232
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in PEP 3147."
msgstr ""
"이 절차에 대한 더 자세한 정보, 결정들의 순서도를 포함한다, 는 PEP 3147 에 나온다."

#: ../Doc/tutorial/modules.rst:239
msgid "Standard Modules"
msgstr "표준 모듈들"

#: ../Doc/tutorial/modules.rst:243
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter)."
"  Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such "
"modules is a configuration option which also depends on the underlying "
"platform.  For example, the :mod:`winreg` module is only provided on "
"Windows systems. One particular module deserves some attention: "
":mod:`sys`, which is built into every Python interpreter.  The variables "
"``sys.ps1`` and ``sys.ps2`` define the strings used as primary and "
"secondary prompts::"
msgstr ""
"파이썬은 표준 모듈들의 라이브러리가 함께 오는데, 별도의 문서 파이썬 라이브러리 레퍼런스 (이후로는 "
"\"라이브러리 레퍼런스\") 에서 설명한다. 어떤 모듈들은 인터프리터에 내장된다; 이것들은 언어의 "
"핵심적인 부분은 아니지만 그런데도 내장된 연산들에 대한 액세스를 제공하는데, 효율이나 시스템 "
"호출과 같은 운영 체제 기본 요소들에 대한 액세스를 제공하기 위함이다. 그런 모듈들의 집합은 설정 "
"옵션인데 기반 플랫폼 의존적이다. 예를 들어, :mod:`winreg` 모듈은 윈도우 시스템에서만 "
"제공된다. 특별한 모듈 하나는 주목을 받을 필요가 있다: :mod:`sys`. 모든 파이썬 인터프리터에 내장"
"된다. 변수 ``sys.ps1`` 와 ``sys.ps2`` 는 기본과 보조 프롬프트로 사용되는 문자열을 정의한다::"

#: ../Doc/tutorial/modules.rst:266
msgid ""
"These two variables are only defined if the interpreter is in interactive"
" mode."
msgstr ""
"이 두 개의 변수들은 인터프리터가 대화형 모드일 때만 정의된다."

#: ../Doc/tutorial/modules.rst:268
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default "
"path taken from the environment variable :envvar:`PYTHONPATH`, or from a "
"built-in default if :envvar:`PYTHONPATH` is not set.  You can modify it "
"using standard list operations::"
msgstr ""
"변수 ``sys.path`` 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트다. 환경 변수 "
":envvar:`PYTHONPATH` 에서 취한 기본 경로나, :envvar:`PYTHONPATH` 가 설정되지 않는 "
"경우 내장 기본값으로 초기화된다. 표준 리스트 연산을 사용해서 수정할 수 있다::"

#: ../Doc/tutorial/modules.rst:281
msgid "The :func:`dir` Function"
msgstr ":func:`dir` 함수"

#: ../Doc/tutorial/modules.rst:283
msgid ""
"The built-in function :func:`dir` is used to find out which names a "
"module defines.  It returns a sorted list of strings::"
msgstr ""
"내장 함수 :func:`dir` 은 모듈이 정의하는 이름들을 찾는 데 사용된다. 문자열들의 정렬된 "
"리스트를 돌려준다::"

#: ../Doc/tutorial/modules.rst:308
msgid ""
"Without arguments, :func:`dir` lists the names you have defined "
"currently::"
msgstr ""
"인자가 없으면, :func:`dir` 는 현재 정의한 이름들을 나열한다::"

#: ../Doc/tutorial/modules.rst:316
msgid "Note that it lists all types of names: variables, modules, functions, etc."
msgstr "모든 형의 이름을 나열한다는 것에 유의해야 한다: 변수, 모듈, 함수, 등등."

#: ../Doc/tutorial/modules.rst:320
msgid ""
":func:`dir` does not list the names of built-in functions and variables."
"  If you want a list of those, they are defined in the standard module "
":mod:`builtins`::"
msgstr ""
":func:`dir` 은 내장 함수와 변수들의 이름을 나열하지 않는다. 그것들의 목록을 원한다면, 표준 모듈 "
":mod:`builtins` 에 정의되어 있다::"

#: ../Doc/tutorial/modules.rst:359
msgid "Packages"
msgstr "패키지"

#: ../Doc/tutorial/modules.rst:361
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like "
"the use of modules saves the authors of different modules from having to "
"worry about each other's global variable names, the use of dotted module "
"names saves the authors of multi-module packages like NumPy or the Python"
" Imaging Library from having to worry about each other's module names."
msgstr ""
"패키지는 \"점으로 구분된 모듈 이름\" 를 써서 파이썬의 모듈 이름 공간을 구조화하는 방법이다. 예를 "
"들어, 모듈 이름 :mod:`A.B` 는 ``A`` 라는 이름의 패키지에 있는 ``B`` 라는 이름의 서브 모듈을 "
"가리킨다. 모듈의 사용이 다른 모듈의 저자들이 서로의 전역 변수 이름들을 걱정할 필요 없게 만드는 것과 "
"마찬가지로, 점으로 구분된 모듈의 이름들은 NumPy 나 PIL 과 같은 다중 모듈 패키지들의 저자들이 "
"서로의 모듈 이름들을 걱정할 필요 없게 만든다."

#: ../Doc/tutorial/modules.rst:369
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for "
"the uniform handling of sound files and sound data.  There are many "
"different sound file formats (usually recognized by their extension, for "
"example: :file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to "
"create and maintain a growing collection of modules for the conversion "
"between the various file formats. There are also many different "
"operations you might want to perform on sound data (such as mixing, "
"adding echo, applying an equalizer function, creating an artificial "
"stereo effect), so in addition you will be writing a never-ending stream "
"of modules to perform these operations.  Here's a possible structure for "
"your package (expressed in terms of a hierarchical filesystem):"
msgstr ""
"음향 파일과 과 음향 데이터의 일관된 처리를 위한 모듈들의 컬렉션 (\"패키지\") 을 설계하길 "
"원한다고 하자. 여러 종류의 음향 파일 형식이 있으므로 (보통 확장자로 구분된다, 예를 들어: "
":file:`.wav`, :file:`.aiff`, :file:`.au`), 다양한 파일 형식 간의 변환을 위해 계속 "
"늘어나는 모듈들의 컬렉션을 만들고 유지할 필요가 있다. 또한, 음향 데이터에 적용하고자 하는 많은 "
"종류의 연산들도 있으므로 (믹싱, 에코 넣기, 이퀄라이저 기능 적용, 인공적인 스테레오 효과 "
"만들기와 같은), 이 연산들을 수행하기 위한 모듈들을 끊임없이 작성하게 될 것이다. 패키지를 이렇게 "
"구성해 볼 수 있다 (계층적 파일 시스템으로 표현했다):"

#: ../Doc/tutorial/modules.rst:406
msgid ""
"When importing the package, Python searches through the directories on "
"``sys.path`` looking for the package subdirectory."
msgstr ""
"패키지를 임포트할 때, 파이썬은 ``sys.path`` 에 있는 디렉터리들을 검색하면서 패키지 "
"서브 디렉터리를 찾는다."

#: ../Doc/tutorial/modules.rst:409
msgid ""
"The :file:`__init__.py` files are required to make Python treat the "
"directories as containing packages; this is done to prevent directories "
"with a common name, such as ``string``, from unintentionally hiding valid"
" modules that occur later on the module search path. In the simplest "
"case, :file:`__init__.py` can just be an empty file, but it can also "
"execute initialization code for the package or set the ``__all__`` "
"variable, described later."
msgstr ""
"파이썬이 디렉터리를 패키지로 취급하게 만들기 위해서 :file:`__init__.py` 파일이 필요하다; "
"이렇게 하는 이유는 ``string`` 처럼 흔히 쓰는 이름의 디렉터리가, 의도하지 않게 모듈 검색 경로의 "
"뒤에 등장하는 올바른 모듈들을 가리는 일을 방지하기 위함이다. 가장 간단한 경우, "
":file:`__init__.py` 는 그냥 빈 파일일 수 있지만, 패키지의 초기화 코드를 실행하거나 뒤에서 "
"설명하는 ``__all__`` 변수를 설정할 수 있다."

#: ../Doc/tutorial/modules.rst:416
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"패키지 사용자는 패키지로부터 개별 모듈을 임포트할 수 있다, 예를 들어::"

#: ../Doc/tutorial/modules.rst:421
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be "
"referenced with its full name. ::"
msgstr ""
"이것은 서브 모듈 :mod:`sound.effects.echo` 를 로드한다. 전체 이름으로 참조되어야 한다. ::"

#: ../Doc/tutorial/modules.rst:426
msgid "An alternative way of importing the submodule is::"
msgstr "서브 모듈을 임포트하는 다른 방법은 이렇다::"

#: ../Doc/tutorial/modules.rst:430
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without"
" its package prefix, so it can be used as follows::"
msgstr ""
"이것도 서브 모듈 :mod:`echo` 를 로드하고, 패키지 접두어 없이 사용할 수 있게 한다. 그래서 "
"이런 식으로 사용할 수 있다::"

#: ../Doc/tutorial/modules.rst:435
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"또 다른 방법은 원하는 함수나 변수를 직접 임포트하는 것이다::"

#: ../Doc/tutorial/modules.rst:439
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function "
":func:`echofilter` directly available::"
msgstr ""
"또다시, 이것은 서브 모듈 :mod:`echo` 를 로드하지만, 함수 :func:`echofilter` 를 직접 "
"사용할 수 있게 만든다::"

#: ../Doc/tutorial/modules.rst:444
msgid ""
"Note that when using ``from package import item``, the item can be either"
" a submodule (or subpackage) of the package, or some  other name defined "
"in the package, like a function, class or variable.  The ``import`` "
"statement first tests whether the item is defined in the package; if not,"
" it assumes it is a module and attempts to load it.  If it fails to find "
"it, an :exc:`ImportError` exception is raised."
msgstr ""
"``from package import item`` 를 사용할 때, item은 패키지의 서브 모듈 (또는 서브 패키지)"
"일 수도 있고 함수, 클래스, 변수 등 패키지에 정의된 다른 이름들일 수도 있음에 유의해야 한다. "
"``import`` 문은 먼저 item이 패키지에 정의되어 있는지 검사하고, 그렇지 않으면 모듈이라고 가정하고 "
"로드를 시도한다. 찾지 못한다면, :exc:`ImportError` 예외를 일으킨다."

#: ../Doc/tutorial/modules.rst:451
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, "
"each item except for the last must be a package; the last item can be a "
"module or a package but can't be a class or function or variable defined "
"in the previous item."
msgstr ""
"이에 반하여, ``import item.subitem.subsubitem`` 와 같은 문법을 사용할 때, 마지막 것을 "
"제외한 각 항목은 반드시 패키지여야 한다; 마지막 항목은 모듈이나 패키지가 될 수 있지만, 앞의 "
"항목에서 정의된 클래스, 함수, 변수 등이 될 수는 없다."

#: ../Doc/tutorial/modules.rst:460
msgid "Importing \\* From a Package"
msgstr "패키지에서 \\* 임포트 하기"

#: ../Doc/tutorial/modules.rst:464
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, "
"finds which submodules are present in the package, and imports them all."
"  This could take a long time and importing sub-modules might have "
"unwanted side-effects that should only happen when the sub-module is "
"explicitly imported."
msgstr ""
"이제 ``from sound.effects import *`` 라고 쓰면 어떻게 될까? 이상적으로는, 어떻게든 "
"파일 시스템에서 패키지에 어떤 모듈들이 들어있는지 찾은 다음, 그것들 모두를 임포트 하기를 원할 것이다. "
"이렇게 하는 데는 시간이 오래 걸리고 서브 모듈을 임포트 함에 따라 어떤 서브 모듈을 명시적으로 임포트할 "
"경우만 일어나야만 하는 원하지 않는 부수적 효과가 발생할 수 있다."

#: ../Doc/tutorial/modules.rst:470
msgid ""
"The only solution is for the package author to provide an explicit index "
"of the package.  The :keyword:`import` statement uses the following "
"convention: if a package's :file:`__init__.py` code defines a list named "
"``__all__``, it is taken to be the list of module names that should be "
"imported when ``from package import *`` is encountered.  It is up to the "
"package author to keep this list up-to-date when a new version of the "
"package is released.  Package authors may also decide not to support it, "
"if they don't see a use for importing \\* from their package.  For "
"example, the file :file:`sound/effects/__init__.py` could contain the "
"following code::"
msgstr ""
"유일한 해결책은 패키지 저자가 패키지의 색인을 명시적으로 제공하는 것이다. :keyword:`import` "
"문은 다음과 같은 관례가 있다: 패키지의 :file:`__init__.py` 코드가 ``__all__`` "
"이라는 이름의 목록을 제공하면, 이것을 ``from package import *`` 를 만날 때 임포트 해야만 "
"하는 모듈 이름들의 목록으로 받아들인다. 새 버전의 패키지를 출시할 때 이 목록을 최신 상태로 유지하는 "
"것은 패키지 저자의 책임이다. 패키지 저자가 패키지에서 \\* 를 임포트하는 용도가 없다고 판단한다면, "
"이것을 지원하지 않기로 할 수도 있다. 예를 들어, 파일 "
":file:`sound/effects/__init__.py` 는 다음과 같은 코드를 포함할 수 있다::"

#: ../Doc/tutorial/modules.rst:482
msgid ""
"This would mean that ``from sound.effects import *`` would import the "
"three named submodules of the :mod:`sound` package."
msgstr ""
"이것은 ``from sound.effects import *`` 이 :mod:`sound.effects` 패키지의 세 "
"서브 모듈들을 임포트하게 됨을 의미한다."

#: ../Doc/tutorial/modules.rst:485
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import "
"*`` does *not* import all submodules from the package "
":mod:`sound.effects` into the current namespace; it only ensures that the"
" package :mod:`sound.effects` has been imported (possibly running any "
"initialization code in :file:`__init__.py`) and then imports whatever "
"names are defined in the package.  This includes any names defined (and "
"submodules explicitly loaded) by :file:`__init__.py`.  It also includes "
"any submodules of the package that were explicitly loaded by previous "
":keyword:`import` statements.  Consider this code::"
msgstr ""
"``__all__`` 이 정의되지 않으면, 문장 ``from sound.effects import *`` 은 패키지 "
":mod:`sound.effects` 의 모든 서브 모듈들을 현재 이름 공간으로 임포트 하지 *않는다*; 이것은 "
"오직 패키지 :mod:`sound.effects` 가 임포트 되도록 만들고 (:file:`__init__.py` 에 있는 "
"초기화 코드들이 수행될 수 있다), 그 패키지가 정의하는 이름들을 임포트 한다. 이 이름들은 "
":file:`__init__.py` 가 정의하는 모든 이름 (그리고 명시적으로 로드된 서브 모듈들)을 포함한다. "
"이 이름들에는 사전에 :keyword:`import` 문으로 명시적으로 로드된 패키지의 서브 모듈들 역시 포함된다. "
"이 코드를 생각해보자::"

#: ../Doc/tutorial/modules.rst:498
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported"
" in the current namespace because they are defined in the "
":mod:`sound.effects` package when the ``from...import`` statement is "
"executed.  (This also works when ``__all__`` is defined.)"
msgstr ""
"이 예에서, :mod:`echo` 와 :mod:`surround` 모듈이 현재 이름 공간으로 임포트 되는데, "
"``from...import`` 문이 실행될 때 :mod:`sound.effects` 패키지에 정의되기 때문이다. "
"(``__all__`` 이 정의될 때도 마찬가지다.)"

#: ../Doc/tutorial/modules.rst:503
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"설사 어떤 모듈이 ``import *`` 를 사용할 때 특정 패턴을 따르는 이름들만 익스포트 하도록 "
"설계되었다 하더라도, 프로덕션 코드에서는 여전히 좋지 않은 사례로 여겨진다."

#: ../Doc/tutorial/modules.rst:507
msgid ""
"Remember, there is nothing wrong with using ``from Package import "
"specific_submodule``!  In fact, this is the recommended notation unless "
"the importing module needs to use submodules with the same name from "
"different packages."
msgstr ""
"``from Package import specific_submodule`` 을 사용하는데 잘못된 것은 없다는 것을 "
"기억하라! 사실, 임포트하는 모듈이 다른 패키지에서 같은 이름의 서브 모듈을 사용할 필요가 없는 한 "
"권장되는 표기법이다."

#: ../Doc/tutorial/modules.rst:514
msgid "Intra-package References"
msgstr "패키지 내부 간의 참조"

#: ../Doc/tutorial/modules.rst:516
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to "
"submodules of siblings packages.  For example, if the module "
":mod:`sound.filters.vocoder` needs to use the :mod:`echo` module in the "
":mod:`sound.effects` package, it can use ``from sound.effects import "
"echo``."
msgstr ""
"패키지가 서브 패키지들로 구조화될 때 (예에서 나온 :mod:`sound` 패키지처럼), 이웃 패키지의 "
"서브 모듈을 가리키는데 절대 임포트를 사용할 수 있다. 예를 들어, 모듈 "
":mod:`sound.filters.vocoder` 이 :mod:`sound.effects` 패키지의 :mod:`echo` "
"모듈이 필요하면, ``from sound.effects import echo`` 를 사용할 수 있다."

#: ../Doc/tutorial/modules.rst:522
msgid ""
"You can also write relative imports, with the ``from module import name``"
" form of import statement.  These imports use leading dots to indicate "
"the current and parent packages involved in the relative import.  From "
"the :mod:`surround` module for example, you might use::"
msgstr ""
"상대 임포트를 쓸 수도 있는데, ``from module import name`` 형태의 임포트 문을 사용한다. "
"이 임포트는 상대 임포트에 수반되는 현재와 부모 패키지를 가리키기 위해 앞에 붙는 점을 사용한다. "
"예를 들어, :mod:`surround` 모듈에서, 이렇게 사용할 수 있다::"

#: ../Doc/tutorial/modules.rst:531
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always "
"use absolute imports."
msgstr ""
"상대 임포트가 현재 모듈의 이름에 기반을 둔다는 것에 주의해야 한다. 메인 모듈의 이름은 항상 "
"``\"__main__\"`` 이기 때문에, 파이썬 응용 프로그램의 메인 모듈로 사용될 목적의 모듈들은 반드시 절대 "
"임포트를 사용해야 한다."

#: ../Doc/tutorial/modules.rst:537
msgid "Packages in Multiple Directories"
msgstr "여러 디렉터리에 있는 패키지"

#: ../Doc/tutorial/modules.rst:539
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the"
" package's :file:`__init__.py` before the code in that file is executed."
"  This variable can be modified; doing so affects future searches for "
"modules and subpackages contained in the package."
msgstr ""
"패키지는 특별한 어트리뷰트 하나를 더 지원한다, :attr:`__path__`. 이것은 패키지의 "
":file:`__init__.py` 파일을 실행하기 전에, 이 파일이 들어있는 디렉터리의 이름을 포함하는 "
"리스트로 초기화된다. 이 변수는 수정할 수 있다; 그렇게 하면 그 이후로 패키지에 포함된 모듈과 "
"서브 패키지를 검색하는 데 영향을 주게 된다."

#: ../Doc/tutorial/modules.rst:545
msgid ""
"While this feature is not often needed, it can be used to extend the set "
"of modules found in a package."
msgstr ""
"이 기능이 자주 필요하지는 않지만, 패키지에서 발견되는 모듈의 집합을 확장하는 데 사용된다."

#: ../Doc/tutorial/modules.rst:550
msgid "Footnotes"
msgstr "각주"

#: ../Doc/tutorial/modules.rst:551
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; "
"the execution of a module-level function definition enters the function "
"name in the module's global symbol table."
msgstr ""
"사실 함수 정의도 '실행' 되는 '문장' 이다; 모듈 수준의 함수 정의를 실행하면 함수의 이름이 전역 "
"심볼 테이블에 들어간다."


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/datamodel.rst:6
msgid "Data model"
msgstr "데이터 모델"

#: ../Doc/reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "객체, 값, 형"

#: ../Doc/reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""
"객체(:dfn:`Objects`)는 파이썬이 데이터(data)를 추상화한것(abstraction)이다. 파이썬 "
"프로그램의 모든 데이터는 객체나 객체간의 관계로 표현된다. (폰 노이만(Von Neumann)의 "
"\"프로그램 내장식 컴퓨터(stored program computer)\" 모델을 따르고, 또 그 관점에서 코드 "
"역시 객체로 표현된다.)"

#: ../Doc/reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity*"
" never changes once it has been created; you may think of it as the "
"object's address in memory.  The ':keyword:`is`' operator compares the "
"identity of two objects; the :func:`id` function returns an integer "
"representing its identity."
msgstr ""
"모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖는다. 객체의 *아이덴티티* 는 "
"한 번 만들어진 후에는 변경되지 않는다. 메모리 상에서의 객체의 주소로 생각해도 좋다. "
"':keyword:`is`' 연산자는 두 객체의 아이덴티티를 비교한다; :func:`id` 함수는 아이덴티티를 "
"정수로 표현한 값을 돌려준다."

#: ../Doc/reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "CPython 의 경우, ``id(x)`` 는 ``x`` 가 저장된 메모리의 주소다."

#: ../Doc/reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports "
"(e.g., \"does it have a length?\") and also defines the possible values "
"for objects of that type.  The :func:`type` function returns an object's "
"type (which is an object itself).  Like its identity, an object's "
":dfn:`type` is also unchangeable. [#]_"
msgstr ""
"객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, \"길이를 갖고 있나?\") 그 형의 객체들이 가질 수 있는 가능한 값들을 정의한다. :func:`type` 함수는 객체의 형(이 것 역시 객체다)을 돌려준다. 아이덴티티와 마찬가지로, 객체의 형(:dfn:`type`) 역시 변경되지 않는다. [#]_"

#: ../Doc/reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change "
"are said to be *mutable*; objects whose value is unchangeable once they "
"are created are called *immutable*. (The value of an immutable container "
"object that contains a reference to a mutable object can change when the "
"latter's value is changed; however the container is still considered "
"immutable, because the collection of objects it contains cannot be "
"changed.  So, immutability is not strictly the same as having an "
"unchangeable value, it is more subtle.) An object's mutability is "
"determined by its type; for instance, numbers, strings and tuples are "
"immutable, while dictionaries and lists are mutable."
msgstr ""
"어떤 객체들의 *값* 은 변경가능하다. 값을 변경할 수 있는 객체들을 *가변(mutable)* 이라고 "
"한다. 일단 만들어진 후에 값을 변경할 수 없는 객체들을 불변(immutable)이라고 한다. (가변 "
"객체에 대한 참조를 저장하고 있는 불변 컨테이너의 값은 기변 객체의 값이 변할 때 변경된다고 볼 "
"수도 있다; 하지만 저장하고있는 객체들의 집합이 바뀔 수 없기 때문에 컨테이너는 여전히 불변이라고 "
"여겨진다. 따라서 불변성은 엄밀하게는 변경불가능한 값을 갖는 것과는 다르다. 좀 더 미묘하다.) "
"객체의 가변성(mutability)은 그 것의 형에 의해 결정된다; 예를 들어 숫자, 문자열, "
"튜플(tuple)은 불변인 반면, 딕셔너리(dictionary) 와 리스트(list)는 가변이다."

#: ../Doc/reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed "
"to postpone garbage collection or omit it altogether --- it is a matter "
"of implementation quality how garbage collection is implemented, as long "
"as no objects are collected that are still reachable."
msgstr ""
"객체는 결코 명시적으로 파괴되지 않는다; 더 이상 참조되지 않을 때(unreachable) 가비지 "
"수거(garbage collect)된다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락된다 "
"--- 아직 참조되는 객체들을 수거하지 않는이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 "
"문제다."

#: ../Doc/reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) "
"delayed detection of cyclically linked garbage, which collects most "
"objects as soon as they become unreachable, but is not guaranteed to "
"collect garbage containing circular references.  See the documentation of"
" the :mod:`gc` module for information on controlling the collection of "
"cyclic garbage. Other implementations act differently and CPython may "
"change. Do not depend on immediate finalization of objects when they "
"become unreachable (so you should always close files explicitly)."
msgstr ""
"CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) "
"순환적으로 연결된 가비지의 지연된 감지가 추가된다. 이 방법으로 대부분의 객체들을 참조가 제거되자 "
"마자 수거할 수 있다. 하지만 순환 참조가 있는 가비지들을 수거한다는 보장은 없다. 순환적 가비지 "
"수거의 제어에 관한 정보는 :mod:`gc` 모듈 문서를 참조하면된다. 다른 구현들은 다른 식으로 동작하고, "
"CPython 도 변경될 수 있다. 참조가 제거될 때 즉각적으로 파이널리제이션(finalization)되는 "
"것에  의존하지 말아야 한다 (그래서 항상 파일을 명시적으로 닫아주어야 한다)."

#: ../Doc/reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities"
" may keep objects alive that would normally be collectable. Also note "
"that catching an exception with a ':keyword:`try`...\\ :keyword:`except`'"
" statement may keep objects alive."
msgstr ""
"구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않을 경우 수거될 수 있는 객체들을 살아있도록 "
"만들 수 있음에 주의해야 한다. 또한 ':keyword:`try`...\\ :keyword:`except`' 문으로 "
"예외를 잡는 것도 객체를 살아있게 만들 수 있다."

#: ../Doc/reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open "
"files or windows.  It is understood that these resources are freed when "
"the object is garbage-collected, but since garbage collection is not "
"guaranteed to happen, such objects also provide an explicit way to "
"release the external resource, usually a :meth:`close` method. Programs "
"are strongly recommended to explicitly close such objects.  The "
"':keyword:`try`...\\ :keyword:`finally`' statement and the "
"':keyword:`with`' statement provide convenient ways to do this."
msgstr ""
"어떤 객체들은 열린 파일이나 창 같은 \"외부(external)\" 자원들에 대한 참조를 포함한다. 이 "
"자원들은 객체가 가비지 수거될 때 반납된다고 이해되어지지만, 가비지 수거는 보장되는 것이 아니기 "
"때문에, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 제공한다. 보통 :meth:`close` "
"메쏘드다. 프로그램을 작성할 때는 그러한 객체들를 항상 명시적으로 닫아야(close) 한다. "
"':keyword:`try`...\\ :keyword:`finally`' 문과 ':keyword:`with`' 문은 이렇게 "
"하는 편리한 방법을 제공한다."

#: ../Doc/reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries."
"  The references are part of a container's value.  In most cases, when we"
" talk about the value of a container, we imply the values, not the "
"identities of the contained objects; however, when we talk about the "
"mutability of a container, only the identities of the immediately "
"contained objects are implied.  So, if an immutable container (like a "
"tuple) contains a reference to a mutable object, its value changes if "
"that mutable object is changed."
msgstr ""
"어떤 객체들은 다른 객체에 대한 참조를 포함하고 있다. 이런 것들을 *컨테이너(container)* 라고 "
"부른다. 튜플, 리스트, 딕셔너리등이 컨테이너의 예다. 이 참조들은 컨테이너의 값의 일부다. "
"대부분의 경우에, 우리가 컨테이너의 값을 논할 때는, 들어있는 객체들의 아이덴티티 보다는 값을 "
"따진다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 갖고 있는 객체들의 아이덴티티만을 "
"따진다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 갖고 있다면, 그 가변 객체가 "
"변경되면 컨테이너의 값도 변경된다."

#: ../Doc/reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance "
"of object identity is affected in some sense: for immutable types, "
"operations that compute new values may actually return a reference to any"
" existing object with the same type and value, while for mutable objects "
"this is not allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may "
"or may not refer to the same object with the value one, depending on the "
"implementation, but after ``c = []; d = []``, ``c`` and ``d`` are "
"guaranteed to refer to two different, unique, newly created empty lists. "
"(Note that ``c = d = []`` assigns the same object to both ``c`` and "
"``d``.)"
msgstr ""
"형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 준다. 객체의 아이엔티디가 갖는 중요성 "
"조차도 어떤 면에서는 영향을 받는다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 "
"객체들 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있다. 반면에 가변 객체에서는 이런 것이 "
"허용되지 않는다. 예를 들어, ``a = 1; b = 1`` 후에, ``a`` 와 ``b`` 는 값 1을 갖는 "
"동일한 객체일 수도 있고, 아닐 수도 있다. 하지만 ``c = []; d = []`` 후에, ``c`` 와 "
"``d`` 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장된다.(``c = d = "
"[]`` 는 객은 객체를 ``c`` 와 ``d`` 에 대입한다.)"

#: ../Doc/reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "표준 형 계층"

#: ../Doc/reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension "
"modules (written in C, Java, or other languages, depending on the "
"implementation) can define additional types.  Future versions of Python "
"may add types to the type hierarchy (e.g., rational numbers, efficiently "
"stored arrays of integers, etc.), although such additions will often be "
"provided via the standard library instead."
msgstr ""
"아래에 파이썬에 내장된 형들의 목록이 있다. (구현에 따라 C 나 자바나 기타 다른 언어로 작성된) "
"확장 모듈들은 추가의 형을 정의할 수 있다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 "
"(예를 들어, 유리수, 효율적으로 저장된 정수 배열 등등), 표준 라이브러리를 통해 추가될 가능성이 "
"더 높기는 하다."

#: ../Doc/reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the "
"implementation and are not intended for general use.  Their definition "
"may change in the future."
msgstr ""
"아래에 나오는 몇몇 형에 대한 설명은 '특수 어트리뷰트(special attribute)' 를 나열하는 "
"문단을 포함한다. 이 것들은 구현에 접근할 수있는 방법을 제공하는데, 일반적인 사용을 위한 것이 "
"아니다. 정의는 앞으로 변경될 수 있다."

#: ../Doc/reference/datamodel.rst:150
msgid "None"
msgstr ""

#: ../Doc/reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to"
" signify the absence of a value in many situations, e.g., it is returned "
"from functions that don't explicitly return anything. Its truth value is "
"false."
msgstr ""
"이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 내장된 이름 "
"``None`` 을 통해 접근한다. 여러가지 상황에서 값의 부재를 알리는데 사용된다. 예를들어, "
"명시적으로 뭔가를 돌려주지 않는 함수의 반환값이다. 논리값은 거짓이다."

#: ../Doc/reference/datamodel.rst:165
msgid "NotImplemented"
msgstr ""

#: ../Doc/reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if "
"they do not implement the operation for the operands provided.  (The "
"interpreter will then try the reflected operation, or some other "
"fallback, depending on the operator.)  Its truth value is true."
msgstr ""
"이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 내장된 이름 "
"``NotImplemented`` 을 통해 접근한다. 숫자 메쏘드(numeric method)와 비교(rich "
"comparison) 메쏘드는 제공된 피연산자에 대해 연산이 구현되지 않은 경우 이 값을 돌려줘야한다. "
"(그러면 인터프리터는 연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도한다.) 논리값은 참이다."

#: ../Doc/reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "더 자세한 내용은 :ref:`implementing-the-arithmetic-operations` 을 참고하라."

#: ../Doc/reference/datamodel.rst:172
msgid "Ellipsis"
msgstr ""

#: ../Doc/reference/datamodel.rst:170
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"이 형은 하나의 값만을 갖는다. 이 값을 갖는 하나의 객체가 존재한다. 이 객체에는 리터럴 "
"``...`` 이나 내장된 이름 ``Ellipsis`` 을 통해 접근한다. 논리값은 참이다. "

#: ../Doc/reference/datamodel.rst:242
msgid ":class:`numbers.Number`"
msgstr ""

#: ../Doc/reference/datamodel.rst:177
msgid ""
"These are created by numeric literals and returned as results by "
"arithmetic operators and arithmetic built-in functions.  Numeric objects "
"are immutable; once created their value never changes.  Python numbers "
"are of course strongly related to mathematical numbers, but subject to "
"the limitations of numerical representation in computers."
msgstr ""
"이 것들은 숫자 리터럴에 의해 만들어지고, 산순 연산과 내장 산술 함수들이 결과로 돌려준다. 숫자 "
"객체는 불변이다; 한번 값이 만들어지면 결코 변하지 않는다. 파이썬의 숫자는 당연히 수학적인 "
"숫자들과 밀접하게 관련되어 있다, 하지만 컴퓨터의 숫자 표현상의 제약을 받고 있다."

#: ../Doc/reference/datamodel.rst:183
msgid ""
"Python distinguishes between integers, floating point numbers, and "
"complex numbers:"
msgstr ""
"파이썬은 정수, 실수, 복소수를 구분한다:"

#: ../Doc/reference/datamodel.rst:217
msgid ":class:`numbers.Integral`"
msgstr ""

#: ../Doc/reference/datamodel.rst:189
msgid ""
"These represent elements from the mathematical set of integers (positive "
"and negative)."
msgstr ""
"이 것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타낸다."

#: ../Doc/reference/datamodel.rst:192
msgid "There are two types of integers:"
msgstr "두 가지 종류의 정수가 있다:"

#: ../Doc/reference/datamodel.rst:194
msgid "Integers (:class:`int`)"
msgstr "정수 (:class:`int`)"

#: ../Doc/reference/datamodel.rst:196
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in"
" a variant of 2's complement which gives the illusion of an infinite "
"string of sign bits extending to the left."
msgstr ""
"이 것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현한다. 시프트(shift) 와 "
"마스크(mask) 연산이 목적일 때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2's "
"complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된 것과 같은 효과를 준다."

#: ../Doc/reference/datamodel.rst:212
msgid "Booleans (:class:`bool`)"
msgstr "불린 (:class:`bool`)"

#: ../Doc/reference/datamodel.rst:208
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean "
"objects. The Boolean type is a subtype of the integer type, and Boolean "
"values behave like the values 0 and 1, respectively, in almost all "
"contexts, the exception being that when converted to a string, the "
"strings ``\"False\"`` or ``\"True\"`` are returned, respectively."
msgstr ""
"이 것은 논리값 거짓과 참을 나타낸다. ``False`` 와 ``True`` 두 객체만 불린 형 객체다. "
"불린 형은 int 형의 자식형(subtype)이고, 거의 대부분의 상황에서 각기 0 과 1 처럼 동작한다. "
"예외는 문저열로 변환되는 경우인데, 각기 문자열 ``\"False\"`` 와 ``\"True\"`` 가 반환된다."

#: ../Doc/reference/datamodel.rst:216
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative"
" integers."
msgstr ""
"정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미있는 해석을 제공하기 위한 것이다."

#: ../Doc/reference/datamodel.rst:232
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ""

#: ../Doc/reference/datamodel.rst:226
msgid ""
"These represent machine-level double precision floating point numbers. "
"You are at the mercy of the underlying machine architecture (and C or "
"Java implementation) for the accepted range and handling of overflow. "
"Python does not support single-precision floating point numbers; the "
"savings in processor and memory usage that are usually the reason for "
"using these are dwarfed by the overhead of using objects in Python, so "
"there is no reason to complicate the language with two kinds of floating "
"point numbers."
msgstr ""
"이 것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타낸다. 허락되는 값의 "
"범위와 오버플로우의 처리에 관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수 밖에 없다. "
"파이썬은 단정도(single precision) 부동 소수점 수를 지원하지 않는다; 이 것들을 사용하는 "
"이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 비용과 상쇄되어 "
"미미해진다. 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없다."

#: ../Doc/reference/datamodel.rst:242
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ""

#: ../Doc/reference/datamodel.rst:239
msgid ""
"These represent complex numbers as a pair of machine-level double "
"precision floating point numbers.  The same caveats apply as for floating"
" point numbers. The real and imaginary parts of a complex number ``z`` "
"can be retrieved through the read-only attributes ``z.real`` and "
"``z.imag``."
msgstr ""
"이 것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타낸다. 부동 소수점 수와 한계와 "
"문제점을 공유한다. 복소수 ``z`` 의 실수부와 허수부는, 읽기 전용 어트리뷰트 ``z.real`` 와 "
"``z.imag`` 로 꺼낼 수 있다."

#: ../Doc/reference/datamodel.rst:359
msgid "Sequences"
msgstr "시퀀스들"

#: ../Doc/reference/datamodel.rst:252
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers "
"0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서있는 집합을 나타낸다. 내장함수 "
":func:`len` 은 시퀀스가 갖고 있는 항목들의 개수를 돌려준다. 시퀀스의 길이가 *n* 일 때, "
"인덱스(index) 집합은 숫자 0, 1, ..., *n*-1 을 포함한다. 시퀀스의 항목 *i* 는 "
"``a[i]`` 로 선택된다."

#: ../Doc/reference/datamodel.rst:259
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index "
"*k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a "
"slice is a sequence of the same type.  This implies that the index set is"
" renumbered so that it starts at 0."
msgstr ""
"시퀀스는 슬라이싱도 지원한다: ``a[i:j]`` 는 *i* ``<=`` *k* ``<`` *j* 를 만족하는 "
"모든 항목 *k* 를 선택한다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스다. 인덱스 집합은 "
"0 에서 시작되도록 다시 번호 매겨진다."

#: ../Doc/reference/datamodel.rst:264
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x"
" = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"어떤 시퀀스는 세번째 \"스텝(step)\" 파라미터를 사용하는 \"확장 슬라이싱(extended "
"slicing)\"도 지원한다: ``a[i:j:k]`` 는  = i + n*k``, *n* ``>=`` ``0``, *i* "
"``<=`` *x* ``<`` *j* 를 만족하는 모든 항목 *x* 를 선택한다."

#: ../Doc/reference/datamodel.rst:268
msgid "Sequences are distinguished according to their mutability:"
msgstr "시퀀스는 불변성에 따라 구분된다"

#: ../Doc/reference/datamodel.rst:325
msgid "Immutable sequences"
msgstr "불변 시퀀스"

#: ../Doc/reference/datamodel.rst:275
msgid ""
"An object of an immutable sequence type cannot change once it is created."
"  (If the object contains references to other objects, these other "
"objects may be mutable and may be changed; however, the collection of "
"objects directly referenced by an immutable object cannot change.)"
msgstr ""
"불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없다. (만약 다른 객체로의 참조를 "
"포함하면, 그 객체는 가변일 수 있고, 변경될 수 있다; 하지만, 불변 객체로 부터 참조되는 객체의 "
"집합 자체는 변경될 수 없다.)"

#: ../Doc/reference/datamodel.rst:280
msgid "The following types are immutable sequences:"
msgstr "다음과 같은 형들은 불변 시퀀스다:"

#: ../Doc/reference/datamodel.rst:303
msgid "Strings"
msgstr "문자열(Strings)"

#: ../Doc/reference/datamodel.rst:293
msgid ""
"A string is a sequence of values that represent Unicode code points. All "
"the code points in the range ``U+0000 - U+10FFFF`` can be represented in "
"a string.  Python doesn't have a :c:type:`char` type; instead, every code"
" point in the string is represented as a string object with length ``1``."
"  The built-in function :func:`ord` converts a code point from its string"
" form to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an "
"integer in the range ``0 - 10FFFF`` to the corresponding length ``1`` "
"string object. :meth:`str.encode` can be used to convert a :class:`str` "
"to :class:`bytes` using the given text encoding, and :meth:`bytes.decode`"
" can be used to achieve the opposite."
msgstr ""
"문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스다. ``U+0000 "
"- U+10FFFF`` 범위의 모든 코드 포인트들은 문자열로 표현될 수 있다. 파이썬에는 "
":c:type:`char` 형이 없다. 대신에 문자열에 있는 각 코드 포인트는 길이 ``1`` 인 문자열 "
"객체로 표현된다. 내장 함수 :func:`ord` 는 코드 포인트를 문자열 형식에서 ``0 - 10FFFF`` "
"범위의 정수로 변환한다; :func:`chr` 은 범위 ``0 - 10FFFF`` 의 정수를 해당하는 길이 "
"``1`` 의 문자열 객체로 변환한다. :meth:`str.encode` 는 주어진 인코딩을 사용해서 "
":class:`str` 을 :class:`bytes` 로 변환하고, :meth:`bytes.decode` 는 그 반대 "
"작업을 수행한다."

#: ../Doc/reference/datamodel.rst:316
msgid "Tuples"
msgstr "튜플(Tuples)"

#: ../Doc/reference/datamodel.rst:311
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one"
" item (a 'singleton') can be formed by affixing a comma to an expression "
"(an expression by itself does not create a tuple, since parentheses must "
"be usable for grouping of expressions).  An empty tuple can be formed by "
"an empty pair of parentheses."
msgstr ""
"튜플의 항목은 임의의 파이썬 객체다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 "
"목록으로 만들 수 있다. 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 "
"붙여서 만들 수 있다(괄호로 표현식을 묶을 수 있기 때문에, 표현식 만으로는 튜플을 만들지 않는다). "
"빈 튜플은 한쌍의 빈 괄호로 만들 수 있다."

#: ../Doc/reference/datamodel.rst:325
msgid "Bytes"
msgstr "바이트열(Bytes)"

#: ../Doc/reference/datamodel.rst:321
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"바이트열(bytes) 객체는 불변 배열이다. 항목은 8-비트 바이트인데, 0 <= x < 256 범위의 "
"정수로 표현된다. 바이트 객체를 만들 때는 바이트열 리터럴(``b'abc'`` 와 같은) 과 내장 "
":func:`bytes()` 생성자(constructor)를 사용할 수 있다. 또한, 바이트열 객체는 "
":meth:`~bytes.decode` 메쏘드를 통해 문자열로 디코딩될 수 있다."

#: ../Doc/reference/datamodel.rst:359
msgid "Mutable sequences"
msgstr "가변 시퀀스"

#: ../Doc/reference/datamodel.rst:335
msgid ""
"Mutable sequences can be changed after they are created.  The "
"subscription and slicing notations can be used as the target of "
"assignment and :keyword:`del` (delete) statements."
msgstr ""
"가변 시퀀스는 만들어진 후에 변경될 수 있다. 서브스크립션(subscription)과 슬라이싱은 대입문과 "
":keyword:`del` (삭제) 문의 대상으로 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:339
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "현재 두 개의 내장 가변 시퀀스형이 있다:"

#: ../Doc/reference/datamodel.rst:346
msgid "Lists"
msgstr "리스트(Lists)"

#: ../Doc/reference/datamodel.rst:344
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note "
"that there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"리스트의 항목은 임의의 파이썬 객체다. 리스트는 콤마로 분리된 표현식을 꺽쇠괄호 안에 넣어서 만들 "
"수 있다. (길이 0 이나 1의 리스트를 만드는데 별도의 규칙이 필요없다.)"

#: ../Doc/reference/datamodel.rst:354
msgid "Byte Arrays"
msgstr "바이트 배열(Byte Arrays)"

#: ../Doc/reference/datamodel.rst:351
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"비이트 배열(bytearray) 객체는 가변 배열이다. 내장 :func:`bytearray` 생성자로 "
"만들어진다. 가변이라는 것(그래서 해싱불가하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( "
":class:`bytes`) 객체와 같은 인터페이스와 기능을 제공한다."

#: ../Doc/reference/datamodel.rst:358
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"확장 모듈 :mod:`array` 는 추가의 가변 시퀀스 형을 제공하는데, :mod:`collections` 모듈 "
"역시 마찬가지다."

#: ../Doc/reference/datamodel.rst:393
msgid "Set types"
msgstr "집합 형들(Set types)"

#: ../Doc/reference/datamodel.rst:366
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be "
"iterated over, and the built-in function :func:`len` returns the number "
"of items in a set. Common uses for sets are fast membership testing, "
"removing duplicates from a sequence, and computing mathematical "
"operations such as intersection, union, difference, and symmetric "
"difference."
msgstr ""
"이 것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타낸다. 인덱싱할 수 없다. 하지만 "
"순환(iterate)할 수 있고, 내장 함수 :func:`len` 은 집합 안에 있는 항목들의 개수를 돌려준다. "
"집합의 일반적인 용도는 빠른 멤버쉽 검사(fast membership testing), 시퀀스에서 중복된 항목 "
"제거, 교집합(intersection), 합집합(union), 차집합(difference), 대칭차집합(symmetric"
" difference)과 같은 집합 연산을 계산하는 것이다."

#: ../Doc/reference/datamodel.rst:373
msgid ""
"For set elements, the same immutability rules apply as for dictionary "
"keys. Note that numeric types obey the normal rules for numeric "
"comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only "
"one of them can be contained in a set."
msgstr ""
"집합의 원소들에는 딕셔너리 키와 동일한 불변성 규칙이 적용된다. 숫자형의 경우는 숫자 비교에 관한 "
"일반 원칙이 적용된다는 점에 주의해야 한다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1``과 "
"``1.0``), 그 중 하나만 집합에 들어갈 수 있다."

#: ../Doc/reference/datamodel.rst:378
msgid "There are currently two intrinsic set types:"
msgstr "현재 두 개의 내장 집합 형이 있다:"

#: ../Doc/reference/datamodel.rst:385
msgid "Sets"
msgstr "집합(Sets)"

#: ../Doc/reference/datamodel.rst:383
msgid ""
"These represent a mutable set. They are created by the built-in "
":func:`set` constructor and can be modified afterwards by several "
"methods, such as :meth:`~set.add`."
msgstr ""
"이 것들은 가변 집합을 나타낸다. 내장 :func:`set` 생성자로 만들 수 있고, :meth:`~set"
".add` 같은 메쏘드들을 사용해서 나중에 수정할 수 있다."

#: ../Doc/reference/datamodel.rst:393
msgid "Frozen sets"
msgstr "불변 집합(Frozen sets)"

#: ../Doc/reference/datamodel.rst:390
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or "
"as a dictionary key."
msgstr ""
"이 것들은 불변 집합을 나타낸다. 내장 :func:`frozenset` 생성자로 만들 수 있다. "
"불변집합(frozenset)은 불변이고 해싱가능(:term:`hashable`)하기 때문에, 다른 집합의 "
"원소나, 딕셔너리의 키로 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:430
msgid "Mappings"
msgstr "매핑(Mappings)"

#: ../Doc/reference/datamodel.rst:401
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. "
"The subscript notation ``a[k]`` selects the item indexed by ``k`` from "
"the mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function "
":func:`len` returns the number of items in a mapping."
msgstr ""
"이 것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타낸다. 인덱스 "
"표기법(subscript notation) ``a[k]`` 는 매핑 ``a`` 에서 ``k`` 로 인덱스되는 항목을 "
"선택한다; 이 것은 표현식에 사용될 수도 있고, 대입이나 :keyword:`del` 문장의 대상이 될 수도 "
"있다. 내장 함수 :func:`len` 은 매필에 포함된 항목들의 개수를 돌려준다."

#: ../Doc/reference/datamodel.rst:407
msgid "There is currently a single intrinsic mapping type:"
msgstr "현재 한 개의 내장 매핑 형이 있다:"

#: ../Doc/reference/datamodel.rst:430
msgid "Dictionaries"
msgstr "딕셔너리(Dictionaries)"

#: ../Doc/reference/datamodel.rst:412
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary "
"values.  The only types of values not acceptable as keys are values "
"containing lists or dictionaries or other mutable types that are compared"
" by value rather than by object identity, the reason being that the "
"efficient implementation of dictionaries requires a key's hash value to "
"remain constant. Numeric types used for keys obey the normal rules for "
"numeric comparison: if two numbers compare equal (e.g., ``1`` and "
"``1.0``) then they can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"이 것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타낸다. 키로 사용할 수 "
"없는 것들은 리스트, 딕셔너리나 그 외의 가변형들 중에서 아이덴티티가 아니라 값으로 비교되는 것들 "
"뿐이다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 변경되지 않고 계속 같은 값으로 "
"유지되도록 요구하고 있기 때문이다. 키로 사용되는 숫자형의 경우는 숫자 비교에 관한 일반 원칙이 "
"적용된다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1``과 ``1.0``), 둘다 같은 딕셔너리 "
"항목을 인덱싱하는데 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:421
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation "
"(see section :ref:`dict`)."
msgstr ""
"딕셔너리는 가변이다; ``{...}`` 표기법으로 만들 수 있다 (:ref:`dict` 섹션을 참고하라)."

#: ../Doc/reference/datamodel.rst:428
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide "
"additional examples of mapping types, as does the :mod:`collections` "
"module."
msgstr ""
"확장 모듈 :mod:`dbm.ndbm` 과 :mod:`dbm.gnu` 는 추가의 매핑 형을 제공하는데, "
":mod:`collections` 모듈 역시 마찬가지다."

#: ../Doc/reference/datamodel.rst:686
msgid "Callable types"
msgstr "콜러블(Callable types)"

#: ../Doc/reference/datamodel.rst:439
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr ""
"이 것들은 함수 호출 연산(:ref:`calls` 섹션 참고)이 적용될 수 있는 형들이다:"

#: ../Doc/reference/datamodel.rst:534
msgid "User-defined functions"
msgstr "사용자 정의 함수"

#: ../Doc/reference/datamodel.rst:448
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter "
"list."
msgstr ""
"사용자 정의 함수 객체는 함수 정의를 통해 만들어진다 (:ref:`function` 섹션 참고). 함수의 "
"형식 인자(formal parameter) 목록과 동일한 개수의 항목을 포함하는 인자(argument) "
"목록으로 호출되어야 한다."

#: ../Doc/reference/datamodel.rst:453
msgid "Special attributes:"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../Doc/reference/datamodel.rst:471
msgid "Attribute"
msgstr "어트리뷰트"

#: ../Doc/reference/datamodel.rst:471
msgid "Meaning"
msgstr "의미"

#: ../Doc/reference/datamodel.rst:473
msgid ":attr:`__doc__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:473
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses"
msgstr ""
"함수를 설명하는 문자열 또는 없는 경우 ``None``; 자식 클래스에게 계승되지 않는다"

#: ../Doc/reference/datamodel.rst:473 ../Doc/reference/datamodel.rst:478
#: ../Doc/reference/datamodel.rst:481 ../Doc/reference/datamodel.rst:486
#: ../Doc/reference/datamodel.rst:490 ../Doc/reference/datamodel.rst:496
#: ../Doc/reference/datamodel.rst:506 ../Doc/reference/datamodel.rst:514
#: ../Doc/reference/datamodel.rst:521
msgid "Writable"
msgstr "쓰기가능"

#: ../Doc/reference/datamodel.rst:478
msgid ":attr:`~definition.\\ __name__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:478
msgid "The function's name"
msgstr "함수의 이름"

#: ../Doc/reference/datamodel.rst:481
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:481
msgid "The function's :term:`qualified name`"
msgstr "함수의 전체 이름(:term:`qualified name`)"

#: ../Doc/reference/datamodel.rst:486
msgid ":attr:`__module__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:486
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../Doc/reference/datamodel.rst:490
msgid ":attr:`__defaults__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:490
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value"
msgstr ""
"인자의 기본 값 또는 (없는 경우) `None` 으로 만들어진 튜플"

#: ../Doc/reference/datamodel.rst:496
msgid ":attr:`__code__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:496
msgid "The code object representing the compiled function body."
msgstr "컴파일된 함수의 바디(body) 를 나타내는 코드 객체"

#: ../Doc/reference/datamodel.rst:499
msgid ":attr:`__globals__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:499
msgid ""
"A reference to the dictionary that holds the function's global variables "
"--- the global namespace of the module in which the function was defined."
msgstr ""
"함수의 전역 변수들을 갖고있는 딕셔너리에 대한 참조 --- 함수가 정의된 모듈의 전역 이름공간(namespace)"

#: ../Doc/reference/datamodel.rst:499 ../Doc/reference/datamodel.rst:510
msgid "Read-only"
msgstr "읽기전용"

#: ../Doc/reference/datamodel.rst:506
msgid ":attr:`~object.__dict__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:506
msgid "The namespace supporting arbitrary function attributes."
msgstr "임의의 함수 어트리뷰트를 지원하는 이름공간."

#: ../Doc/reference/datamodel.rst:510
msgid ":attr:`__closure__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:510
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's "
"free variables."
msgstr ""
"``None`` 또는 함수의 자유 변수(free variable)들에 대한 연결을 갖고 있는 셀(cell)들의 "
"튜플."

#: ../Doc/reference/datamodel.rst:514
msgid ":attr:`__annotations__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:514
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are "
"the parameter names, and ``'return'`` for the return annotation, if "
"provided."
msgstr ""
"파라미터의 어노테이션을 갖고 있는 dict. dict 의 키는 파라미터의 이름인데, 반환값 어노테이션이 "
"있다면 ``'return'`` 을 키로 사용한다."

#: ../Doc/reference/datamodel.rst:521
msgid ":attr:`__kwdefaults__`"
msgstr ""

#: ../Doc/reference/datamodel.rst:521
msgid "A dict containing defaults for keyword-only parameters."
msgstr "키워드 형태로만 전달 가능한 파라미터들의 기본값을 갖고 있는 dict."

#: ../Doc/reference/datamodel.rst:525
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the "
"assigned value."
msgstr ""
"\"쓰기가능\" 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사한다."

#: ../Doc/reference/datamodel.rst:527
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular"
" attribute dot-notation is used to get and set such attributes. *Note "
"that the current implementation only supports function attributes on "
"user-defined functions. Function attributes on built-in functions may be "
"supported in the future.*"
msgstr ""
"함수 객체는 임의의 어트리뷰트를 읽고 쓸수 있도록 지원하는데, 예를 들어 함수에 메타데이터"
"(metadata)를 붙이는데 사용될 수 있다. 어트리뷰트를 읽거나 쓸 때에는 일반적인 점 "
"표현법(dot-notation)이 사용된다. *현재 구현은 오직 사용자 정의 함수만 함수 어트리뷰트를 "
"지원함에 주의해야 한다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있다.*"

#: ../Doc/reference/datamodel.rst:533
msgid ""
"Additional information about a function's definition can be retrieved "
"from its code object; see the description of internal types below."
msgstr ""
"함수 정의에 관한 추가적인 정보를 코드 객체로부터 얻을 수 있다. 아래에 나오는 내부 형의 기술을 "
"참고하라."

#: ../Doc/reference/datamodel.rst:603
msgid "Instance methods"
msgstr "인스턴스 메쏘드(Instance methods)"

#: ../Doc/reference/datamodel.rst:542
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"인스턴스 메쏘드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합한다."

#: ../Doc/reference/datamodel.rst:552
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); "
":attr:`~definition.__name__` is the method name (same as "
"``__func__.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`__self__` 는 클래스 인스턴스 객체, "
":attr:`__func__` 는 함수 객체; :attr:`__doc__` 은 메쏘드의 설명 (``__func__"
".__doc__`` 과 같다); :attr:`~definition.__name__` 은 메쏘드의 이름 (``__func__"
".__name__`` 과 같다); :attr:`__module__` 은 메쏘드가 정의된 모듈의 이름이거나 없는 "
"경우 ``None``."

#: ../Doc/reference/datamodel.rst:558
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""
"메쏘드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원한다(하지만 쓰기는 지원하지 "
"않는다)."

#: ../Doc/reference/datamodel.rst:561
msgid ""
"User-defined method objects may be created when getting an attribute of a"
" class (perhaps via an instance of that class), if that attribute is a "
"user-defined function object or a class method object."
msgstr ""
"어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메쏘드 객체인 경우, 사용자 정의 메쏘드 객체는 "
"클래스의 어트리뷰트를 읽을 때 만들어질 수 있다 (아마도 그 클래스의 인스턴스를 통해서)."

#: ../Doc/reference/datamodel.rst:565
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its "
":attr:`__self__` attribute is the instance, and the method object is said"
" to be bound.  The new method's :attr:`__func__` attribute is the "
"original function object."
msgstr ""
"인스턴스 메쏘드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 "
"만들어질 때, :attr:`__self__` 어트리뷰트는 인스턴스이고, 메쏘드 객체는 결합(bound)되었다고"
" 말한다. 새 메쏘드의 :attr:`__func__` 어트리뷰트는 원래의 함수 객체다."

#: ../Doc/reference/datamodel.rst:571
msgid ""
"When a user-defined method object is created by retrieving another method"
" object from a class or instance, the behaviour is the same as for a "
"function object, except that the :attr:`__func__` attribute of the new "
"instance is not the original method object but its :attr:`__func__` "
"attribute."
msgstr ""
"클래스나 인스턴스로 부터 다른 메쏘드 객체를 읽음으로써 사용자 정의 메쏘드 객체가 만들어질 때, 새 "
"인스턴스의 :attr:`__func__` 어트리뷰트가 원래의 메쏘드 객체가 아니라, 그 것의 "
":attr:`__func__` 어트리뷰트라는 점만 제외하고는 함수 객체의 경우와 같은 방식으로 동작한다."

#: ../Doc/reference/datamodel.rst:577
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the "
"class itself, and its :attr:`__func__` attribute is the function object "
"underlying the class method."
msgstr ""
"인스턴스 메쏘드 객체가 클래스나 인스턴스로 부터 클래스 메쏘드 객체를 읽음으로써 만들어질 때, "
":attr:`__self__` 어트리뷰트는 클래스 자신이고, :attr:`__func__` 어트리뷰트는 클래스 "
"메쏘드가 기반하는 함수 객체다."

#: ../Doc/reference/datamodel.rst:582
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`__func__`) is called, inserting the class instance "
"(:attr:`__self__`) in front of the argument list.  For instance, when "
":class:`C` is a class which contains a definition for a function "
":meth:`f`, and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is "
"equivalent to calling ``C.f(x, 1)``."
msgstr ""
"인스턴스 메쏘드 객체가 호출될 때, 기반하는 함수 (:attr:`__func__`) 가 호출되는데, 인자 "
"목록의 앞에 클래스 인스턴스 (:attr:`__self__`) 가 삽입된다. 예를 들어, :class:`C` 가 "
"함수 :meth:`f` 의 정의를 포함하는 클래스이고, ``x`` 가 :class:`C` 의 인스턴스일 때, "
"``x.f(1)`` 를 호출하는 것은 ``C.f(x, 1)`` 을 호출하는 것과 같다."

#: ../Doc/reference/datamodel.rst:589
msgid ""
"When an instance method object is derived from a class method object, the"
" \"class instance\" stored in :attr:`__self__` will actually be the class"
" itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to"
" calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"인스턴스 메쏘드 객체가 클래스 메쏘드 객체로부터 올 때, :attr:`__self__` 에 저장된 \"클래스 "
"인스턴스\" 는 실제로는 클래스 자신이다. 그래서 ``x.f(1)`` 이나 ``C.f(1)`` 을 호출하는 "
"것은 ``f(C,1)`` 를 호출하는 것과 같다 (``f`` 는 기반 함수다)."

#: ../Doc/reference/datamodel.rst:594
msgid ""
"Note that the transformation from function object to instance method "
"object happens each time the attribute is retrieved from the instance.  "
"In some cases, a fruitful optimization is to assign the attribute to a "
"local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions"
" which are attributes of a class instance are not converted to bound "
"methods; this *only* happens when the function is an attribute of the "
"class."
msgstr ""
"함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 어트리뷰트를 읽을 때마다 일어남에 주의해야 "
"한다. 어떤 경우에, 어트리뷰트를 지역 변수에 대입하고, 그 지역 변수를 호출하는 것이 효과적인 "
"최적화가 된다. 또한 이 변환이 사용자 정의 함수에 대해서만 발생함에 주의해야 한다; 다른 콜러블 "
"객체 (그리고 콜러블이 아닌 모든 객체들)는 변환 없이 읽혀진다. 클래스 인스턴스의 어트리뷰트인 "
"사용자 정의 함수는 결합된 메쏘드로 변환되지 않는 다는 것도 중요하다; 이 변환은 함수가 클래스 "
"어트리뷰트일 때만 일어난다."

#: ../Doc/reference/datamodel.rst:618
msgid "Generator functions"
msgstr "제너레이터 함수(Generator functions)"

#: ../Doc/reference/datamodel.rst:610
msgid ""
"A function or method which uses the :keyword:`yield` statement (see "
"section :ref:`yield`) is called a :dfn:`generator function`.  Such a "
"function, when called, always returns an iterator object which can be "
"used to execute the body of the function:  calling the iterator's "
":meth:`iterator.__next__` method will cause the function to execute until"
" it provides a value using the :keyword:`yield` statement.  When the "
"function executes a :keyword:`return` statement or falls off the end, a "
":exc:`StopIteration` exception is raised and the iterator will have "
"reached the end of the set of values to be returned."
msgstr ""
":keyword:`yield` 문(:ref:`yield` 절 참조)을 사용하는 함수나 메쏘드를 제너레이터 "
"함수(:dfn:`generator function`)라고 부른다. 이런 함수를 호출하면 항상 이터레이터"
"(iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하는데 사용된다: 이터레이터의 "
":meth:`iterator.__next__` 메쏘드를 호출하면 :keyword:`yield` 문이 값을 제공할 "
"때까지 함수가 실행된다. 함수가 :keyword:`return` 문을 실행하거나 끝에 도달하면 "
":exc:`StopIteration` 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 된다."

#: ../Doc/reference/datamodel.rst:628
msgid "Coroutine functions"
msgstr "코루틴 함수(Coroutine functions)"

#: ../Doc/reference/datamodel.rst:624
msgid ""
"A function or method which is defined using :keyword:`async def` is "
"called a :dfn:`coroutine function`.  Such a function, when called, "
"returns a :term:`coroutine` object.  It may contain :keyword:`await` "
"expressions, as well as :keyword:`async with` and :keyword:`async for` "
"statements. See also the :ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수나 메쏘드를 코루틴 함수(:dfn:`coroutine "
"function`)라고 부른다. 이런 함수를 호출하면 코루틴(:term:`coroutine`) 객체를 돌려준다. "
":keyword:`await` 표현식을 비롯해, :keyword:`async with` 와 :keyword:`async "
"for` 문을 사용할 수 있다. :ref:`coroutine-objects` 섹션을 참조."

#: ../Doc/reference/datamodel.rst:647
msgid "Asynchronous generator functions"
msgstr "비동기 제너레이터 함수(Asynchronous generator functions)"

#: ../Doc/reference/datamodel.rst:635
msgid ""
"A function or method which is defined using :keyword:`async def` and "
"which uses the :keyword:`yield` statement is called a :dfn:`asynchronous "
"generator function`.  Such a function, when called, returns an "
"asynchronous iterator object which can be used in an :keyword:`async for`"
" statement to execute the body of the function."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수가 :keyword:`yield` 문을 사용하면 "
"비동기 제너레이터 함수(:dfn:`asynchronous generator function`)라고 부른다. 이런 "
"함수를 호출하면 항상 비동기 이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 "
"바디(body)를 실행하기위해  :keyword:`async for` 문에서 사용된다."

#: ../Doc/reference/datamodel.rst:641
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method "
"will return an :term:`awaitable` which when awaited will execute until it"
" provides a value using the :keyword:`yield` expression.  When the "
"function executes an empty :keyword:`return` statement or falls off the "
"end, a :exc:`StopAsyncIteration` exception is raised and the asynchronous"
" iterator will have reached the end of the set of values to be yielded."
msgstr ""
"비동기 이터레이터의 :meth:`aiterator.__anext__` 메쏘드를 호출하면 어웨이터블"
"(:term:`awaitable`)을 돌려주는데, await 할 때 :keyword:`yield` 문이 값을 제공할 "
"때까지 함수가 실행된다. 함수가 빈 :keyword:`return` 문을 실행하거나 끝에 도달하면 "
":exc:`StopAsyncIteration` 예외를 일으키고, 비동기 이터레이터는 반환하는 값들의 끝에 "
"도달하게 된다."

#: ../Doc/reference/datamodel.rst:662
msgid "Built-in functions"
msgstr "내장 함수(Built-in functions)"

#: ../Doc/reference/datamodel.rst:655
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of"
" built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is "
"a standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: "
":attr:`__doc__` is the function's documentation string, or ``None`` if "
"unavailable; :attr:`~definition.__name__` is the function's name; "
":attr:`__self__` is set to ``None`` (but see the next item); "
":attr:`__module__` is the name of the module the function was defined in "
"or ``None`` if unavailable."
msgstr ""
"내장 함수 객체는 C 함수를 둘러싸고 있다(wrapper). 내장 함수의 예로는 :func:`len` 과 "
":func:`math.sin` (:mod:`math` 는 표준 내장 모듈이다) 가 있다. 인자의 개수와 형은 C "
"함수에 의해결정된다. 특수 읽기 전용 어트리뷰트들: :attr:`__doc__` 은 함수의 설명 문자열 "
"또는 없는 경우 ``None`` 이다; :attr:`~definition.__name__` 은 함수의 이름이다; "
":attr:`__self__` 는 ``None`` 으로 설정된다 (하지만 다음 항목을 보라); "
":attr:`__module__` 은 함수가 정의된 모듈의 이름이거나 없는 경우 ``None`` 이다."

#: ../Doc/reference/datamodel.rst:674
msgid "Built-in methods"
msgstr "내장 메쏘드(Built-in methods)"

#: ../Doc/reference/datamodel.rst:670
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, "
"assuming *alist* is a list object. In this case, the special read-only "
"attribute :attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"이 것은 사실 내장 함수의 다른 모습이다. 이번에는 암묵적인 추가의 인자로 C 함수에게 전달되는 "
"객체를 갖고 있다. 내장 메쏘드의 예로는 ``alist.append()`` 가 있는데, *alist* 는 리스트 "
"객체다. 이 경우에, 특수 읽기 전용 어트리뷰트 :attr:`__self__` 는 *alist* 로 표현된 "
"객체로 설정된다."

#: ../Doc/reference/datamodel.rst:681
msgid "Classes"
msgstr "클래스(Classes)"

#: ../Doc/reference/datamodel.rst:677
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that"
" override :meth:`__new__`.  The arguments of the call are passed to "
":meth:`__new__` and, in the typical case, to :meth:`__init__` to "
"initialize the new instance."
msgstr ""
"클래스는 콜러블이다. 이 객체들은 보통 자신의 새로운 인스턴스를 만드는 팩토리(factory)로 "
"동작하는데, :meth:`__new__` 메쏘드를 재정의(override) 하는 클래스 형에서는 달라질 수도 "
"있다. 호출 인자는 :meth:`__new__` 로 전달되고, 일반적인 경우에, 새 인스턴스를 초기화하기 "
"위해 :meth:`__init__` 로도 전달된다."

#: ../Doc/reference/datamodel.rst:686
msgid "Class Instances"
msgstr "클래스 인스턴스(Class Instances)"

#: ../Doc/reference/datamodel.rst:684
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`__call__` method in their class."
msgstr ""
"클래스에서 :meth:`__call__` 메쏘드를 정의함으로써, 클래스 인스턴스를 콜러블로 만들 수 있다."

#: ../Doc/reference/datamodel.rst:736
msgid "Modules"
msgstr "모듈(Modules)"

#: ../Doc/reference/datamodel.rst:693
msgid ""
"Modules are a basic organizational unit of Python code, and are created "
"by the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement (see :keyword:`import`), or by calling "
"functions such as :func:`importlib.import_module` and built-in "
":func:`__import__`.  A module object has a namespace implemented by a "
"dictionary object (this is the dictionary referenced by the "
"``__globals__`` attribute of functions defined in the module).  Attribute"
" references are translated to lookups in this dictionary, e.g., ``m.x`` "
"is equivalent to ``m.__dict__[\"x\"]``. A module object does not contain "
"the code object used to initialize the module (since it isn't needed once"
" the initialization is done)."
msgstr ""
"모듈은 파이썬 코드의 기본적인 조직화 단위이고, :keyword:`import` 문(:keyword:`import`"
" 를 참고)이나, :func:`importlib.import_module` 과 내장 :func:`__import__` "
"함수를 호출해서 구동할 수 있는 :ref:`임포트 시스템 <importsystem>` 에 의해 만들어진다. "
"모듈 객체는 딕셔너리 객체로 구현되는 이름공간을 갖는다(이 딕셔너리 객체는 모듈에서 정의되는 "
"함수들의 ``__globals__`` 어트리뷰트로 참조된다). 어트리뷰트 참조는 이 딕셔너리에 대한 "
"조회로 변환된다. 예를 들어, ``m.x`` 는 ``m.__dict__[\"x\"]`` 와 같다. 모듈 객체는 "
"모듈을 초기화하는데 사용된 코드 객체를 갖고있지 않다 (일단 초기화가 끝나면 필요없기 때문에)."

#: ../Doc/reference/datamodel.rst:705
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., "
"``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"어트리뷰트 대입은 모듈의 이름공간 딕셔너리를 갱신한다. 예를들어, ``m.x = 1`` 은 ``m"
".__dict__[\"x\"] = 1`` 과 같다."

#: ../Doc/reference/datamodel.rst:715
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary "
"containing :term:`variable annotations <variable annotation>` collected "
"during module body execution; :attr:`__file__` is the pathname of the "
"file from which the module was loaded, if it was loaded from a file. The "
":attr:`__file__` attribute may be missing for certain types of modules, "
"such as C modules that are statically linked into the interpreter; for "
"extension modules loaded dynamically from a shared library, it is the "
"pathname of the shared library file."
msgstr ""
"미리 정의된 (쓰기 가능한) 어트리뷰트들: :attr:`__name__` 은 모듈의 이름이다; "
":attr:`__doc__` 은 모듈의 설명 문자열 또는 없는 경우 ``None`` 이다; (없을 수도 있는) "
":attr:`__annotations__` 는 모듈의 바디를 실행하면서 수집된 변수 어노테이션"
"(:term:`variable annotations <variable annotation>`)들을 담은 딕셔너리다; "
":attr:`__file__` 은 모듈이 로드된 파일의 경로명이다. 인터프리터에 정적으로 연결된 C 모듈과 "
"같은 어떤 종류의 모듈들 에서는 :attr:`__file__` 어트리뷰트가 제공되지 않는다; 공유 "
"라이브러리(shared library)로부터 동적으로 로딩되는 확장 모듈의 경우 공유 라이브러리의 "
"경로명이 제공된다."

#: ../Doc/reference/datamodel.rst:728
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`~object.__dict__` 는 딕셔너리로 표현되는 모듈의 이름 "
"공간이다."

#: ../Doc/reference/datamodel.rst:733
msgid ""
"Because of the way CPython clears module dictionaries, the module "
"dictionary will be cleared when the module falls out of scope even if the"
" dictionary still has live references.  To avoid this, copy the "
"dictionary or keep the module around while using its dictionary directly."
msgstr ""
"CPython 이 모듈 딕셔너리를 비우는 방법때문에, 딕셔너리에 대한 참조가 남어있더라도, 모듈이 "
"스콥을 벗어나면 모듈 딕셔너리는 비워진다. 이 것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 "
"이용하는 동안은 모듈을 잡아두어야 한다."

#: ../Doc/reference/datamodel.rst:795
msgid "Custom classes"
msgstr "사용자 정의 클래스(Custom classes)"

#: ../Doc/reference/datamodel.rst:739
msgid ""
"Custom class types are typically created by class definitions (see "
"section :ref:`class`).  A class has a namespace implemented by a "
"dictionary object. Class attribute references are translated to lookups "
"in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` "
"(although there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes. This search of the base "
"classes uses the C3 method resolution order which behaves correctly even "
"in the presence of 'diamond' inheritance structures where there are "
"multiple inheritance paths leading back to a common ancestor. Additional "
"details on the C3 MRO used by Python can be found in the documentation "
"accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"사용자 정의 클래스 형들은 보통 클래스 정의에 의해 만들어진다 (:ref:`class` 섹션 참조). "
"클래스는 딕셔너리로 구현된 이름공간을 갖는다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 "
"변환된다. 예를 들어, ``C.x`` 는 ``C.__dict__[\"x\"]`` 로 변환된다 (하지만 "
"어트리뷰트에 접근하는 다른 방법들을 허락하는 여러가지 훅(hook)이 있다.). 거기에서 어트리뷰트 "
"이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속된다. 이 부모 클래스 검색은 C3 "
"메쏘드 검색 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 글래스로 "
"모이는 '다이아몬드(diamond)' 계승 구조가 존재해도 올바르게 동작한다. 파이썬이 사용하는 C3 "
"MRO 에 관한 좀 더 자세한 내용은 2.3 릴리즈에 첨부된 문서 "
"https://www.python.org/download/releases/2.3/mro/ 에서 찾아볼 수 있다."

#: ../Doc/reference/datamodel.rst:763
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield "
"a class method object, it is transformed into an instance method object "
"whose :attr:`__self__` attributes is :class:`C`.  When it would yield a "
"static method object, it is transformed into the object wrapped by the "
"static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"클래스 어트리뷰트 참조가 (클래스 :class:`C` 라고 하자) 클래스 메쏘드 객체로 귀결될 때는, "
":attr:`__self__` 어트리뷰트가 :class:`C` 인 인스턴스 메쏘드 객체로 변환된다. 스태틱 "
"메쏘드로 귀결될 때는, 스태틱 메쏘드 객체가 감싸고 있는 객체로 변환된다. 클래스로 부터 얻은 "
"어트리뷰트가 :attr:`~object.__dict__` 에 저장된 값과 달라지도록 만드는 다른 방법이 "
":ref:`descriptors` 섹션에 나온다."

#: ../Doc/reference/datamodel.rst:773
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 "
"건드리지는 않는다."

#: ../Doc/reference/datamodel.rst:778
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보라) 호출될 수 있다(위를 보라)."

#: ../Doc/reference/datamodel.rst:788
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's "
"namespace; :attr:`~class.__bases__` is a tuple containing the base "
"classes, in the order of their occurrence in the base class list; "
":attr:`__doc__` is the class's documentation string, or ``None`` if "
"undefined; :attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during class"
" body execution."
msgstr ""
"특수 어트리뷰트들::attr:`~definition.__name__` 은 클래스의 이름이다. "
":attr:`__module__` 은 클래스가 정의된 모듈의 이름이다. :attr:`~object.__dict__` "
"는 클래스의 이름공간을 저장하는 딕셔너리다; :attr:`~class.__bases__` 는 부모 클래스들을 "
"저장하는 튜플이다; 부모 클래스 목록에 나타나는 순서를 유지한다; :attr:`__doc__` 은 클래스의 "
"설명 문자열 이거나 정의되지 않은 경우 ``None`` 이다;  (없을 수 있는) "
":attr:`__annotations__` 는 클래스의 바디를 실행하면서 수집된 변수 어노테이션"
"(:term:`variable annotations <variable annotation>`)들을 담은 딕셔너리다."

#: ../Doc/reference/datamodel.rst:838
msgid "Class instances"
msgstr "클래스 인스턴스(Class instances)"

#: ../Doc/reference/datamodel.rst:804
msgid ""
"A class instance is created by calling a class object (see above).  A "
"class instance has a namespace implemented as a dictionary which is the "
"first place in which attribute references are searched.  When an "
"attribute is not found there, and the instance's class has an attribute "
"by that name, the search continues with the class attributes.  If a class"
" attribute is found that is a user-defined function object, it is "
"transformed into an instance method object whose :attr:`__self__` "
"attribute is the instance.  Static method and class method objects are "
"also transformed; see above under \"Classes\".  See section "
":ref:`descriptors` for another way in which attributes of a class "
"retrieved via its instances may differ from the objects actually stored "
"in the class's :attr:`~object.__dict__`.  If no class attribute is found,"
" and the object's class has a :meth:`__getattr__` method, that is called "
"to satisfy the lookup."
msgstr ""
"클래스 인스턴스는 클래스 객체를 호출해서 (위를 보라) 만들어진다. 클래스 인스턴스는 딕셔너리로 "
"구현되는 이름공간을 갖는데, 어트리뷰트를 참조할 때 가장 먼저 검색되는 곳이다. 그 곳에서 "
"어트리뷰트가 발견되지 않고, 인스턴스의 클래스가 그 이름의 어트리뷰트를 갖고 있으면, 클래스 "
"어트리뷰트로 검색이 계속된다. 만약 발견된 클래스 어트리뷰트가 사용자 정의 함수면, "
":attr:`__self__` 어트리뷰트가 인스턴스인 인스턴스 메쏘드로 변환된다. 스태틱 메쏘드와 클래스 "
"메쏘드 객체또한 변환된다. 위의 \"사용자 정의 클래스(Custom  Classes)\" 부분을 보라. "
"클래스로 부터 얻은 어트리뷰트가 클래스의 :attr:`~object.__dict__` 에 저장된 값과 "
"달라지도록 만드는 다른 방법이 :ref:`descriptors` 섹션에 나온다. 만약 클래스 어트리뷰트도 "
"발견되지 않고, 클래스가 :meth:`__getattr__` 메쏘드를 가지면, 조회를 만족시키기 위해 그 "
"메쏘드를 호출한다."

#: ../Doc/reference/datamodel.rst:820
msgid ""
"Attribute assignments and deletions update the instance's dictionary, "
"never a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"어트리뷰트 대입과 삭제는 인스턴스의 딕셔너리를 갱신할뿐, 결코 클래스의 딕셔너리를 건드리지 "
"않는다. 만약 클래스가 :meth:`__setattr__` 이나 :meth:`__delattr__` 메쏘드를 가지면, "
"인스턴스의 딕셔너리를 갱신하는 대신에 그 메쏘드들을 호출한다."

#: ../Doc/reference/datamodel.rst:830
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they"
" have methods with certain special names.  See section "
":ref:`specialnames`."
msgstr ""
"어떤 특별한 이름들의 메쏘드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인척 할 수 있다. "
":ref:`specialnames` 섹션을 보라."

#: ../Doc/reference/datamodel.rst:837
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary;"
" :attr:`~instance.__class__` is the instance's class."
msgstr ""
"특수 어트리뷰트들: :attr:`~object.__dict__` 는 어트리뷰트 딕셔너리다; "
":attr:`~instance.__class__` 는 인스턴스의 클래스다."

#: ../Doc/reference/datamodel.rst:864
msgid "I/O objects (also known as file objects)"
msgstr "I/O 객체 (파일 객체라고도 알려져있다)"

#: ../Doc/reference/datamodel.rst:854
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and"
" also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
"파일 객체(:term:`file object`)는 열린 파일을 나타낸다. 파일 객체를 만드는 여러가지 "
"단축법이 있다: :func:`open` 내장 함수, :func:`os.popen`, :func:`os.fdopen` 과 "
"소켓 객체의 :meth:`~socket.socket.makefile` 메쏘드 (그리고, 아마도 확장 모듈들이 "
"제공하는 다른 함수들이나 메쏘드들)."

#: ../Doc/reference/datamodel.rst:860
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are "
"initialized to file objects corresponding to the interpreter's standard "
"input, output and error streams; they are all open in text mode and "
"therefore follow the interface defined by the :class:`io.TextIOBase` "
"abstract class."
msgstr ""
"``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 는 인터프리터의 표준 입력, 출력, "
"에러 스트림으로 초기화된 파일 객체들이다; 모두 텍스트 모드로 열려서 :class:`io.TextIOBase`"
" 추상 클래스에 의해 정의된 인터페이스를 따른다."

#: ../Doc/reference/datamodel.rst:1070
msgid "Internal types"
msgstr "내부 형(Internal types)"

#: ../Doc/reference/datamodel.rst:871
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but"
" they are mentioned here for completeness."
msgstr ""
"인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출된다. 인터프리터의 미래 버전에서 "
"이들의 정의는 변경될 수 있지만, 완점함을 위해 여기서 언급한다."

#: ../Doc/reference/datamodel.rst:939
msgid "Code objects"
msgstr "코드 객체(Code objects)"

#: ../Doc/reference/datamodel.rst:878
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function "
"object is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code "
"object contains no context; also the default argument values are stored "
"in the function object, not in the code object (because they represent "
"values calculated at run-time).  Unlike function objects, code objects "
"are immutable and contain no references (directly or indirectly) to "
"mutable objects."
msgstr ""
"코드 객체는 *바이트로 컴파일된(byte-compiled)* 실행가능한 파이썬코드을 나타내는데, 그냥 "
"바이트코드(:term:`bytecode`)라고도 부른다. 코드 객체와 함수 객체간에는 차이가 있다; 함수 "
"객체는 함수의 전역공간(globals) (함수가 정의된 모듈)에 대한 명시적인 참조를 갖고 있는 반면, "
"코드 객체는 어떤 문맥(context)도 갖고 있지 않다; 또한 기본 인자값들이 함수 객체에 저장되어 "
"있는 반면 코드 객체에는 들어있지 않다 (실행 시간에 계산되는 값들을 나타내기 때문이다). 함수 "
"객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) "
"갖고 있지 않다."

#: ../Doc/reference/datamodel.rst:903
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the number of positional arguments (including "
"arguments with default values); :attr:`co_nlocals` is the number of local"
" variables used by the function (including arguments); "
":attr:`co_varnames` is a tuple containing the names of the local "
"variables (starting with the argument names); :attr:`co_cellvars` is a "
"tuple containing the names of local variables that are referenced by "
"nested functions; :attr:`co_freevars` is a tuple containing the names of "
"free variables; :attr:`co_code` is a string representing the sequence of "
"bytecode instructions; :attr:`co_consts` is a tuple containing the "
"literals used by the bytecode; :attr:`co_names` is a tuple containing the"
" names used by the bytecode; :attr:`co_filename` is the filename from "
"which the code was compiled; :attr:`co_firstlineno` is the first line "
"number of the function; :attr:`co_lnotab` is a string encoding the "
"mapping from bytecode offsets to line numbers (for details see the source"
" code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding"
" a number of flags for the interpreter."
msgstr ""
"특수 읽기전용 어트리뷰트들: :attr:`co_name` 은 함수의 이름이다; :attr:`co_argcount` "
"는 위치지정 인자들 (기본값이 있는 인자들도 포함된다)의 개수다; :attr:`co_nlocals` 는 "
"함수가 사용하는 지역 변수들 (인자들을 포함한다)의 개수다; :attr:`co_varnames` 는 지역 "
"변수들의 이름을 담고 있는 튜플이다(인자들의 이름이 먼저 나온다); :attr:`co_cellvars` 는 "
"중첩된 함수들이 참조하는 지역변수들의 이름을 담고있는 튜플이다; :attr:`co_freevars` 는 "
"자유 변수(free variables)들의 이름을 담고 있는 튜플이다; :attr:`co_code` 는 "
"바이트코드 명령 시퀀스를 나타내는 문자열이다; :attr:`co_consts` 는 바이트코드가 사용하는 "
"리터럴을 포함하는 튜플이다; :attr:`co_names` 는 바이트코드가 사용하는 이름들을 담고 있는 "
"튜플이다; :attr:`co_filename` 은 컴파일된 코드를 제공한 파일의 이름이다; "
":attr:`co_firstlineno` 는 함수의 첫번째 줄 번호다; :attr:`co_lnotab` 은 "
"바이트코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 인코딩한 값이다 (자세한 내용은 "
"인터프리터의 소스 코드를 참고 하라); :attr:`co_stacksize` 는 필요한 스택의 크기다 (지역 "
"변수를 포함한다); :attr:`co_flags` 는 인터프리터의 여러 플랙(flag)들을 정수로 인코딩한 "
"값이다."

#: ../Doc/reference/datamodel.rst:922
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is"
" set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator."
msgstr ""
"다음과 같은 값을이 :attr:`co_flags` 를 위해 정의되어 있다: 함수가 가변 개수의 위치지정 "
"인자를 받아들이기 위해 사용되는 ``*arguments`` 문법을 사용하면 비트 ``0x04`` 가 1이된다; "
"임의의 키워드 인자를 받아들이기 위해 사용하는 ``**keywords`` 문법을 사용하면 비트 "
"``0x08`` 이 1 이 된다; 비트 ``0x20`` 은 함수가 제너레이터일 때 설정된다."

#: ../Doc/reference/datamodel.rst:928
msgid ""
"Future feature declarations (``from __future__ import division``) also "
"use bits in :attr:`co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""
"퓨처 기능 선언 (``from __future__ import division``) 또한 코드 객체가 특정 기능이 "
"활성화된 상태에서 컴파일되었는지 여부를 나타내기 위해 :attr:`co_flags` 의 비트들을 "
"사용한다: 함수가 퓨처 division 이 활성화 된 상태에서 컴파일 되었으면 비트 ``0x2000`` 이 "
"설정된다; 비트 ``0x10`` 과 ``0x1000`` 는 예전 버전의 파이썬에서 사용되었다."

#: ../Doc/reference/datamodel.rst:934
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` 의 다른 비트들은 내부 사용을 위해 예약되어 있다."

#: ../Doc/reference/datamodel.rst:938
msgid ""
"If a code object represents a function, the first item in "
":attr:`co_consts` is the documentation string of the function, or "
"``None`` if undefined."
msgstr ""
"만약 코드 객체가 함수를 나타낸다면, :attr:`co_consts` 의 첫번째 항목은 설명 문자열이거나 "
"정의되지 않은 경우 ``None`` 이다. "

#: ../Doc/reference/datamodel.rst:988
msgid "Frame objects"
msgstr "프레임 객체(Frame objects)"

#: ../Doc/reference/datamodel.rst:946
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""
"프레임 객체는 실행 프레임(execution frame)을 나타낸다. 트레이스백 객체에 등장할 수 있다 "
"(아래를 보라)."

#: ../Doc/reference/datamodel.rst:957
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack "
"frame (towards the caller), or ``None`` if this is the bottom stack "
"frame; :attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is "
"used for built-in (intrinsic) names; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code "
"object)."
msgstr ""
"특수 읽기전용 어트리뷰트들: :attr:`f_back` 은 이전 스택 프레임 (호출자 방향으로)을 "
"가리키거나 이게 스택의 바닥이라면 ``None``; :attr:`f_code` 는 이 프레임에서 실행되는 "
"코드 객체; :attr:`f_locals` 는 지역 변수를 조회하는데 사용되는 딕셔너리; "
":attr:`f_globals` 는 전역 변수에 사용된다; :attr:`f_builtins` 는 내장된(intrinsic)"
" 이름들에 사용된다; :attr:`f_lasti` 는 정확한 바이트코드 명령(instruction)을 제공한다 "
"(코드 객체의 바이트코드 문자열에 대한 인덱스다). "

#: ../Doc/reference/datamodel.rst:969
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a "
"function called at the start of each source code line (this is used by "
"the debugger); :attr:`f_lineno` is the current line number of the frame "
"--- writing to this from within a trace function jumps to the given line "
"(only for the bottom-most frame).  A debugger can implement a Jump "
"command (aka Set Next Statement) by writing to f_lineno."
msgstr ""
"특수 쓰기가능 어트리뷰트들: :attr:`f_trace` 는, ``None`` 이 아니면, 각 소스 코드 줄을 시작할 때 호출되는 함수다 (디버거에서 사용된다); :attr:`f_lineno` 는 프레임의 현재 줄 번호다 --- 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 점프한다 (오직 가장 바닥 프레임에서만 가능하다). 디버거는 f_lineno 를 쓰기위한 점프 명령을 구현할 수 있다 (소위 Set Next Statement)."

#: ../Doc/reference/datamodel.rst:976
msgid "Frame objects support one method:"
msgstr "프레임 객체는 한가지 메쏘드를 지원한다:"

#: ../Doc/reference/datamodel.rst:980
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example "
"when catching an exception and storing its traceback for later use)."
msgstr ""
"이 메쏘드는 프레임이 잡고 있는 지역 변수들에 대한 모든 참조를 제거한다. 또한, 만약 프레임이 "
"제너레이터에 속하면, 제너레이터가 종료된다(finalize). 이 것은 프레임 객체가 관련된 참조 "
"순환을 깨는데 도움을 준다 (예를 들어, 예외를 잡아서 트레이스백을 추후 사용을 위해 저장할 때)."

#: ../Doc/reference/datamodel.rst:986
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr "만약 프레임이 현재 실행중이면 :exc:`RuntimeError` 예외가 발생한다."

#: ../Doc/reference/datamodel.rst:1026
msgid "Traceback objects"
msgstr "트레이스백 객체(Traceback objects)"

#: ../Doc/reference/datamodel.rst:1001
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as the third item of "
"the tuple returned by ``sys.exc_info()``. When the program contains no "
"suitable handler, the stack trace is written (nicely formatted) to the "
"standard error stream; if the interpreter is interactive, it is also made"
" available to the user as ``sys.last_traceback``."
msgstr ""
"트레이스백 객체는 예외의 스택 트레이스를 나타낸다. 트레이스백 객체는 예외가 발생할 때 만들어진다. "
"예외 처리기를 찾아서 실행 스택을 되감을 때, 각 각 되감기 단계마다 현재 트레이스백의 앞에 "
"트레이스백 객체를 삽입한다. 예외 처리기에 들어가면, 스택 트레이스를  프로그램이 사용할 수 있다. "
"(:ref:`try` 섹션 참조.) ``sys.exc_info()`` 가 돌려주는 튜플의 세 번째 항목에 있다. "
"프로그램이 적절한 처리기를 제공하지 않는경우, 스택 트레이스는 표준 오류 스트림으로 (보기 좋게 "
"포맷되어) 출력된다; 만약 인터프리터가 대화형이면, ``sys.last_traceback`` 으로 사용자에게 "
"제공한다."

#: ../Doc/reference/datamodel.rst:1019
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None``"
" if there is no next level; :attr:`tb_frame` points to the execution "
"frame of the current level; :attr:`tb_lineno` gives the line number where"
" the exception occurred; :attr:`tb_lasti` indicates the precise "
"instruction.  The line number and last instruction in the traceback may "
"differ from the line number of its frame object if the exception occurred"
" in a :keyword:`try` statement with no matching except clause or with a "
"finally clause."
msgstr ""
"특수 읽기전용 어트리뷰트들: :attr:`tb_next` 는 스택 트레이스의 다음 단계 (예외가 발생한 "
"프레임 방향으로)이거나 다음 단계가 없으면 ``None`` 이다. :attr:`tb_frame` 은 현 "
"단계에서의 실행 프레임이다; :attr:`tb_lineno` 는 예외가 발생한 줄의 번호를 준다; "
":attr:`tb_lasti` 정확한 바이트코드 명령을 가리킨다. 만약 예외가 except 절이나 finally "
"절이 없는 :keyword:`try` 문에서 발생하면, 줄 번호와 트레이스백의 마지막 명령(last "
"instruction) 은 프레임 객체의 줄 번호와 다를 수 있다."

#: ../Doc/reference/datamodel.rst:1052
msgid "Slice objects"
msgstr "슬라이스 객체(Slice objects)"

#: ../Doc/reference/datamodel.rst:1031
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"슬라이스 객체는 :meth:`__getitem__` 메쏘드를 위한 슬라이스를 나타낸다. 내장 함수 "
":func:`slice` 로 만들 수도 있다."

#: ../Doc/reference/datamodel.rst:1039
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"특수 읽기전용 어트리뷰트들: :attr:`~slice.start` 는 하한(lower bound) 이다; "
":attr:`~slice.stop` 은 상한(upper bound) 이다; :attr:`~slice.step` 은 스텝 "
"값이다; 각 값은 생략될 경우 ``None`` 이다. 이 어트리뷰트들은 임의의 형이 될 수 있다."

#: ../Doc/reference/datamodel.rst:1043
msgid "Slice objects support one method:"
msgstr "슬라이스 객체는 하나의 메쏘드를 지원한다."

#: ../Doc/reference/datamodel.rst:1047
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices "
"are handled in a manner consistent with regular slices."
msgstr ""
"이 메쏘드는 하나의 정수 인자 *length* 를 받아서 슬라이스가 길이 *length* 인 시퀀스에 "
"적용되었을 경우에 대한 정보를 계산한다. 세개의 정수로 구성된 튜플을 돌려준다: 이 것들은 각각 "
"*start* 와 *stop* 인덱스와, *step* 또는 슬라이스의 스트라이드(stride) 길이다. "
"생략되었거나 범위를 벗어난 인덱스들은 일반적인 슬라이스와 동일한 방법으로 다뤄진다."

#: ../Doc/reference/datamodel.rst:1062
msgid "Static method objects"
msgstr "스태틱 메쏘드 객체(Static method objects)"

#: ../Doc/reference/datamodel.rst:1055
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method "
"object is a wrapper around any other object, usually a user-defined "
"method object. When a static method object is retrieved from a class or a"
" class instance, the object actually returned is the wrapped object, "
"which is not subject to any further transformation. Static method objects"
" are not themselves callable, although the objects they wrap usually are."
" Static method objects are created by the built-in :func:`staticmethod` "
"constructor."
msgstr ""
"스태틱 메쏘드 객체는 위에서 설명한 함수 객체를 메쏘드 객체로 변환하는 과정을 방지하는 방법을 "
"제공한다. 스태틱 메쏘드 객체는 다른 임의의 객체, 보통 사용자 정의 메쏘드를 둘러싼다. 스태틱 "
"메쏘드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 돌려주는 것은 둘러싸여져 있던 "
"객체인데, 다른 어떤 변환도 적용되지 않은 상태다. 둘러싸는 객체는 그렇더라도, 스태틱 메쏘드 객체 "
"자체는 콜러블이 아니다. 스태틱 메쏘드 객체는 내장 :func:`staticmethod` 생성자로 만든다."

#: ../Doc/reference/datamodel.rst:1070
msgid "Class method objects"
msgstr "클래스 메쏘드 객체(Class method objects)"

#: ../Doc/reference/datamodel.rst:1065
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from"
" classes and class instances. The behaviour of class method objects upon "
"such retrieval is described above, under \"User-defined methods\". Class "
"method objects are created by the built-in :func:`classmethod` "
"constructor."
msgstr ""
"스태틱 메쏘드 객체처럼, 클래스 메쏘드 객체역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로 "
"부터 그 객를 꺼내는 방식에 변화를 준다. 그런 조회에서 클래스 메쏟 객체가 동작하는 방식에 "
"대해서는 위 \"사용자 정의 메쏘드(User-defined methods)\" 에서 설명했다. 클래스 메쏘드 "
"객체는 내장 :func:`classmethod` 생성자로 만든다."

#: ../Doc/reference/datamodel.rst:1075
msgid "Special method names"
msgstr "특수 메쏘드 이름들"

#: ../Doc/reference/datamodel.rst:1081
msgid ""
"A class can implement certain operations that are invoked by special "
"syntax (such as arithmetic operations or subscripting and slicing) by "
"defining methods with special names. This is Python's approach to "
":dfn:`operator overloading`, allowing classes to define their own "
"behavior with respect to language operators.  For instance, if a class "
"defines a method named :meth:`__getitem__`, and ``x`` is an instance of "
"this class, then ``x[i]`` is roughly equivalent to "
"``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to "
"execute an operation raise an exception when no appropriate method is "
"defined (typically :exc:`AttributeError` or :exc:`TypeError`)."
msgstr ""
"클래스는 특별한 이름의 메쏘드들을 정의함으로써 특별한 문법 (산술 연산이나 인덱싱이나 슬라이딩 "
"같은)에 의해 시작되는 어떤 연산들을 구현할 수 있다. 이 것이 연산자 오버로딩(:dfn:`operator "
"overloading`) 에 대한 파이썬의 접근법인데, 클래스가 언어의 연산자에 대한 자기 자신의 동작을 "
"정의할 수 있도록 한다. 예를 들어, 클래스가 :meth:`__getitem__` 이라는 이름의 메쏘드를 "
"정의하고, ``x`` 가 기 클래스의 인스턴스라면, ``x[i]`` 는 대략 ``type(x).__getitem__"
"(x, i)`` 와 동일하다. 언급된 경우를 제외하고, 적절한 메쏘드가 정의되지 않았을 때 연산은 "
"예외를 일으킨다 (보통 :exc:`AttributeError` 나 :exc:`TypeError`)."

#: ../Doc/reference/datamodel.rst:1091
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets "
":meth:`__iter__` to ``None``, the class is not iterable, so calling "
":func:`iter` on its instances will raise a :exc:`TypeError` (without "
"falling back to :meth:`__getitem__`). [#]_"
msgstr ""
"수 메쏘드를 ``None`` 으로 설정하는 것은 해당 연산이 제공되지 않는다는 것을 가리킨다. 예를 들어, 만약 클래스가 :meth:`__iter__` 를 ``None`` 으로 설정하면, 클래스는 이터러블이 아니다. 따라서 이 인스턴스에 :func:`iter` 를 호출하면 :exc:`TypeError` 가 발생한다. (:meth:`__getitem__` 을 대안으로 시도하지 않는다.) [#]_"

#: ../Doc/reference/datamodel.rst:1097
msgid ""
"When implementing a class that emulates any built-in type, it is "
"important that the emulation only be implemented to the degree that it "
"makes sense for the object being modelled.  For example, some sequences "
"may work well with retrieval of individual elements, but extracting a "
"slice may not make sense.  (One example of this is the "
":class:`~xml.dom.NodeList` interface in the W3C's Document Object Model.)"
msgstr ""
"내장 형을 흉내내는 클래스를 구현할 때, 모방은 모델링하는 객체에게 말이 되는 수준까지만 구현하는 "
"것이 중요하다. 예를 들어, 어떤 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있다. "
"하지만 슬라이스를 꺼내는 것은 말이 안될 수 있다. (이런 한가지 예는 W3C 의 Document Object "
"Model 의 :class:`~xml.dom.NodeList` 인터페이스다.)"

#: ../Doc/reference/datamodel.rst:1108
msgid "Basic customization"
msgstr "기본적인 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1114
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a "
"static method (special-cased so you need not declare it as such) that "
"takes the class of which an instance was requested as its first argument."
"  The remaining arguments are those passed to the object constructor "
"expression (the call to the class).  The return value of :meth:`__new__` "
"should be the new object instance (usually an instance of *cls*)."
msgstr ""
"클래스 *cls* 의 새 인스턴스를 만들기 위해 호출된다. :meth:`__new__` 는 스태틱 메쏘드다 "
"(그렇게 선언하지 않아도 되는 특별한 경우다)인데, 첫번째 인자로 만들려고 하는 인스턴스의 클래스가 "
"전달된다. 나머지 인자들은 객체 생성자 표현(클래스 호출)에 전달된 것들이다. :meth:`__new__` "
"의 반환값은 새 객체 인스턴스이어야 한다 (보통 *cls* 의 인스턴스)."

#: ../Doc/reference/datamodel.rst:1121
msgid ""
"Typical implementations create a new instance of the class by invoking "
"the superclass's :meth:`__new__` method using ``super().__new__(cls[, "
"...])`` with appropriate arguments and then modifying the newly-created "
"instance as necessary before returning it."
msgstr ""
"일반적인 구현은 ``super().__new__(cls[, ...])`` 에 적절한 인자들을 전달하는 방법으로 "
"수퍼클래스의 :meth:`__new__` 를 호출해서 새 인스턴스를 만든 후에, 돌려주기전에 필요한 "
"수정을 가한다."

#: ../Doc/reference/datamodel.rst:1126
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's "
":meth:`__init__` method will be invoked like ``__init__(self[, ...])``, "
"where *self* is the new instance and the remaining arguments are the same"
" as were passed to :meth:`__new__`."
msgstr ""
"만약 :meth:`__new__` 가 *cls* 의 인스턴스를 돌려준다면, 새 인스턴스의 "
":meth:`__init__` 메쏘드가 ``__init__(self[, ...])`` 처럼 호출되는데, *self* 는 "
"새 인스턴스이고, 나머지 인자들은 :meth:`__new__` 로 전달된 것들과 같다."

#: ../Doc/reference/datamodel.rst:1131
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"만약 :meth:`__new__` 가 *cls* 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 "
":meth:`__init__` 는 호출되지 않는다."

#: ../Doc/reference/datamodel.rst:1134
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types"
" (like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` 는 주로 불변형(int, str, tuple과 같은)의 서브클래스가 인스턴스 생성을 "
"커스터마이즈할 수 있도록 하는데 사용된다. 또한 사용자 정의 메타클래스에서 클래스 생성을 "
"커스터마이즈하기 위해 자주 사용된다."

#: ../Doc/reference/datamodel.rst:1143
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but "
"before it is returned to the caller.  The arguments are those passed to "
"the class constructor expression.  If a base class has an "
":meth:`__init__` method, the derived class's :meth:`__init__` method, if "
"any, must explicitly call it to ensure proper initialization of the base "
"class part of the instance; for example: ``super().__init__([args...])``."
msgstr ""
"(:meth:`__new__` 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 "
"호출된다. 인자들은 클래스 생성자 표현으로 전달된 것들이다. 만약 베이스클래스가 "
":meth:`__init__` 메쏘드를 갖고 있다면, 서브클래스의 :meth:`__init__` 메쏘드는, "
"있다면, 인스턴스에서 베이스클래스가 차지하는 부분이 올바르게 초기화됨을 확실히하기 위해 명시적으로 "
"호출해주어야 한다; 예를 들어: ``super().__init__([args...])``."

#: ../Doc/reference/datamodel.rst:1150
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in "
"constructing objects (:meth:`__new__` to create it, and :meth:`__init__` "
"to customize it), no non-``None`` value may be returned by "
":meth:`__init__`; doing so will cause a :exc:`TypeError` to be raised at "
"runtime."
msgstr ""
"객체를 만드는데 :meth:`__new__` 와 :meth:`__init__` 가 협력하고 있기 때문에 "
"(:meth:`__new__` 는 만들고, :meth:`__init__` 는 그 것을 커스터마이즈한다), "
":meth:`__init__` 가 ``None`` 이외의 값을 돌려주면 실행시간에 :exc:`TypeError` 를 "
"일으킨다."

#: ../Doc/reference/datamodel.rst:1162
msgid ""
"Called when the instance is about to be destroyed.  This is also called a"
" destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure"
" proper deletion of the base class part of the instance.  Note that it is"
" possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"It may then be called at a later time when this new reference is deleted."
"  It is not guaranteed that :meth:`__del__` methods are called for "
"objects that still exist when the interpreter exits."
msgstr ""
"인스턴스가 파괴되기 직전에 호출된다. 파괴자(desctuctor)라고도 부른다. 만약 베이스클래스가 "
":meth:`__del__` 메쏘드를 갖고 있다면, 자식 클래스의 :meth:`__del__` 메쏘드는, 정의 "
"되어 있다면, 인스턴스에서 베이스클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 "
"베이스클래스의 메쏘드를 호출해야 한다. (권장하지는 않지만) "
":meth:`__del__` 메쏘드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 "
"수 있다는 것에 주의해야 한다. 추후 이 참조가 삭제될 때 호출될 수 있다. 인터프리터가 종료할 때 "
"아직 남아있는 객체들에 대해서는 :meth:`__del__` 메쏘드의 호출이 보장되지 않는다."

#: ../Doc/reference/datamodel.rst:1174
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements"
" the reference count for ``x`` by one, and the latter is only called when"
" ``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree"
" data structure with parent and child pointers); a reference to the "
"object on the stack frame of a function that caught an exception (the "
"traceback stored in ``sys.exc_info()[2]`` keeps the stack frame alive); "
"or a reference to the object on the stack frame that raised an unhandled "
"exception in interactive mode (the traceback stored in "
"``sys.last_traceback`` keeps the stack frame alive).  The first situation"
" can only be remedied by explicitly breaking the cycles; the second can "
"be resolved by freeing the reference to the traceback object when it is "
"no longer useful, and the third can be resolved by storing ``None`` in "
"``sys.last_traceback``. Circular references which are garbage are "
"detected and cleaned up when the cyclic garbage collector is enabled "
"(it's on by default). Refer to the documentation for the :mod:`gc` module"
" for more information about this topic."
msgstr ""
"``del x`` 는 직접 ``x.__del__()`` 를 호출하지 않는다 --- 앞의 것은 ``x`` 의 참조 "
"회수(reference count)를 하나 감소 시키고, 뒤의 것은 ``x`` 의 참조 회수가 0 이 될 때 "
"호출된다. 객체의 참조 회수가 0이 되지 못하게 막는 일반적인 상황에는 이런 것들이 있다: 객체들 "
"간의 순환 참조 (예를 들어 이증 링크 리스트(doubly-linked list) 나 부모와 자식을 가리키는 "
"트리 자료 구조(tree data structure)); 예외를 잡은 함수의 스택 프레임에 있는 객체에 대한 "
"참조 (``sys.exc_info()[2]`` 에 저장된 트레이스백은 스택프레임이 살아있도록 만든다); "
"대화형 환경에서 잡히지 않은 예외(unhandled exception)를 일으킨 스택프레임의 객체에 대한 "
"참조(``sys.last_traceback`` 에 저장된 트레이스백은 스택프레임이 살아있도록 만든다). "
"첫번째 상황은 오직 명시적으로 순환을 끊어주는 방법으로만 해결될 수 있다; 두번째는 더이상 필요없을 "
"때 트레이스백에 대한 참조를 풀어주는 것으로 해결된다; 세번째는 ``sys.last_traceback`` 에 "
"``None`` 을 저장하는 것으로 해결될 수 있다. 가비지인 순환 참조는 감지될 수 있고, 가비지 "
"수집기(garbage collector)가 활성화되면 제거될 수 있다(기본적으로 활성화 된다). 이 주제에 "
"대한 자세한 내용은 :mod:`gc` 모듈을 참고하면된다."

#: ../Doc/reference/datamodel.rst:1196
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods "
"are invoked, exceptions that occur during their execution are ignored, "
"and a warning is printed to ``sys.stderr`` instead.  Also, when "
":meth:`__del__` is invoked in response to a module being deleted (e.g., "
"when execution of the program is done), other globals referenced by the "
":meth:`__del__` method may already have been deleted or in the process of"
" being torn down (e.g. the import machinery shutting down).  For this "
"reason, :meth:`__del__` methods should do the absolute minimum needed to "
"maintain external invariants.  Starting with version 1.5, Python "
"guarantees that globals whose name begins with a single underscore are "
"deleted from their module before other globals are deleted; if no other "
"references to such globals exist, this may help in assuring that imported"
" modules are still available at the time when the :meth:`__del__` method "
"is called."
msgstr ""
":meth:`__del__` 이 호출되는 불안정한 상황 때문에, 이 것이 실행중에 발생 시키는 예외는 "
"무시되고, 대신에 ``sys.stderr`` 로 경고가 출력된다. 또한, 모듈이 삭제되는 것으로 "
"인해(예를들어 프로그램이 실행을 종료할 때) :meth:`__del__` 이 호출될 때는, "
":meth:`__del__` 가 참조하는 다른 전역 객체들이 이미 삭제되었거나 해체되고 있는 과정에 있을 "
"수 있다(예를들어 임포트 기작이 종료중이다). 이런 이유로, :meth:`__del__` 메쏘드는 외부의 "
"변화에 영향 받을 수 있는 작업을 최소화해야 한다. 버전 1.5부터, 파이썬은 이름이 하나의 밑줄로 "
"시작하는 전역 객체가 다른 전역 객체들보다 먼저 삭제됨을 보장한다; 이 것은, 만약 그 전역 "
"객체들에 대한 다른 참조가 존재하지 않는다면, :meth:`__del__` 메쏘드가 호출되는 시점에, "
"임포트된 모듈들이 남아있도록 확실히 하는데 도움이 될 수 있다."

#: ../Doc/reference/datamodel.rst:1217
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look"
" like a valid Python expression that could be used to recreate an object "
"with the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should"
" be returned. The return value must be a string object. If a class "
"defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` "
"is also used when an \"informal\" string representation of instances of "
"that class is required."
msgstr ""
":func:`repr` 내장 함수에 의해 호출되어 객체의 \"형식적인(official)\" 문자열 표현을 "
"계산한다. 만약 가능하다면, 이 것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 "
"수 있는 올바른 파이썬 표현식처럼 보여야 한다. 가능하지 않다면, ``<...쓸모있는 설명...>`` "
"형태의 문자열을 돌려줘야 한다. 반환값은 반드시 문자열이어야 한다. 만약 클래스가 "
":meth:`__str__` 없이 :meth:`__repr__` 만 정의한다면, :meth:`__repr__` 은 그 "
"클래스 인스턴스의 \"비형식적인(informal)\" 문자열 표현이 요구될 때 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:1226
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""
"이 것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않도록 만드는 것이 중요하다."

#: ../Doc/reference/datamodel.rst:1237
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions "
":func:`format` and :func:`print` to compute the \"informal\" or nicely "
"printable string representation of an object.  The return value must be a"
" :ref:`string <textseq>` object."
msgstr ""
":func:`str(object) <str>` 와 내장 함수 :func:`format`, :func:`print` 에 의해 "
"호출되어 객체의 \"비형식적인(informal)\" 또는 보기좋게 인쇄가능한 문자열 표현을 계산한다. "
"반환값은 반드시 :ref:`문자열 <textseq>` 객체여야 한다."

#: ../Doc/reference/datamodel.rst:1242
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more"
" convenient or concise representation can be used."
msgstr ""
"이 메쏘드는 :meth:`__str__` 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 "
"점에서  :meth:`object.__repr__` 과 다르다: 더 편리하고 간결한 표현이 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:1246
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"내장 형 :class:`object` 에 정의된 기본 구현은 :meth:`object.__repr__` 을 호출한다."

#: ../Doc/reference/datamodel.rst:1256
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string "
"representation of an object. This should return a :class:`bytes` object."
msgstr ""
":ref:`bytes <func-bytes>` 에 의해 호출되어 객체의 바이트문자열 표현을 계산한다. 반환값은 반드시 :class:`bytes` 객체여야 한다."

#: ../Doc/reference/datamodel.rst:1267
msgid ""
"Called by the :func:`format` built-in function, and by extension, "
"evaluation of :ref:`formatted string literals <f-strings>` and the "
":meth:`str.format` method, to produce a \"formatted\" string "
"representation of an object. The ``format_spec`` argument is a string "
"that contains a description of the formatting options desired. The "
"interpretation of the ``format_spec`` argument is up to the type "
"implementing :meth:`__format__`, however most classes will either "
"delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
":func:`format` 내장 함수, 확대하면, :ref:`포맷 문자열 리터럴(formatted string "
"literals) <f-strings>` 의 계산과 :meth:`str.format` 메쏘드에 의해 호출되어, 객체의 "
"\"포맷된\" 문자열 표현을 만들어낸다. ``format_spec`` 인자는 요구되는 포맷 옵션들을 "
"포함하는 문자열이다. ``format_spec`` 인자의 해석은 :meth:`__format__` 을 구현하는 "
"형에 달려있으나, 대부분의 클래스들은 포맷팅을 내향형들의 하나로 위임하거나, 비슷한 포맷 옵션 "
"문법을 사용한다."

#: ../Doc/reference/datamodel.rst:1277
msgid "See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "표준 포맷칭 문법에 대해서는 :ref:`formatspec` 를 참고하면 된다."

#: ../Doc/reference/datamodel.rst:1279
msgid "The return value must be a string object."
msgstr "반환값은 반드시 문자열이어야 한다."

#: ../Doc/reference/datamodel.rst:1281
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"``object`` 의 __format__ 메쏘드 자신은, 빈문자열이 아닌 인자가 전달되면 "
":exc:`TypeError` 를 발생시킨다."

#: ../Doc/reference/datamodel.rst:1297
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"이 것들은 소위 \"풍부한 비교(rich comparison)\" 메쏘드다. 연산자 기호와 메쏘드 이름들 "
"간의 관계는 다음과 같다: ``x<y`` 는 ``x.__lt__(y)`` 를 호출한다, ``x<=y`` 는 "
"``x.__le__(y)`` 를 호출한다, ``x==y`` 는 ``x.__eq__(y)`` 를 호출한다, ``x!=y`` "
"는 ``x.__ne__(y)`` 를 호출한다, ``x>y`` 는 ``x.__gt__(y)`` 를 호출한다, "
"``x>=y`` 는 ``x.__ge__(y)`` 를 호출한다."

#: ../Doc/reference/datamodel.rst:1303
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful "
"comparison. However, these methods can return any value, so if the "
"comparison operator is used in a Boolean context (e.g., in the condition "
"of an ``if`` statement), Python will call :func:`bool` on the value to "
"determine if the result is true or false."
msgstr ""
"풍부한 비교 메쏘드는 주어진 한쌍의 인자에 대해 해당 연산을 구현하지 않는 경우 단일자"
"(singleton) ``NotImplemented`` 를 돌려줄 수 있다. 관례상, 성공적인 비교인 경우 "
"``False`` 나 ``True`` 를 돌려준다. 하지만, 이 메쏘드는 어떤 형의 값이건 돌려줄 수 있다, "
"그래서 비교 연산자가 논리 문맥(Boolean context) (에를 들어 ``if`` 문의 조건) 에서 "
"사용되면, 파이썬은 결과의 참거짓을 파악하기 위해 값에 대해 :func:`bool` 을 호출한다."

#: ../Doc/reference/datamodel.rst:1310
msgid ""
"By default, :meth:`__ne__` delegates to :meth:`__eq__` and inverts the "
"result unless it is ``NotImplemented``.  There are no other implied "
"relationships among the comparison operators, for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""
"기본적으로, :meth:`__ne__` 는 :meth:`__eq__` 를 호출 한후 ``NotImplemented`` 가 "
"아니라면 그 결과를 뒤집는다. 비교 연산자들 간의 다른 암묵적인 관계는 없다. 예를들어, ``(x<y "
"or x==y)`` 가 참이라고 해서 ``x<=y`` 가 참일 필요는 없다. 하나의 기본 연산으로 부터 "
"대소관계 연산을 자동작으로 만들어내려면 :func:`functools.total_ordering` 를 보면된다."

#: ../Doc/reference/datamodel.rst:1317
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on "
"creating :term:`hashable` objects which support custom comparison "
"operations and are usable as dictionary keys."
msgstr ""
"사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 해시테이블(:term:`hashable`) 객체를 만드는 것에 "
"관한 몇가지 중요한 내용이 :meth:`__hash__` 에 관한 문단에 나온다."

#: ../Doc/reference/datamodel.rst:1321
msgid ""
"There are no swapped-argument versions of these methods (to be used when "
"the left argument does not support the operation but the right argument "
"does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's "
"reflection, :meth:`__le__` and :meth:`__ge__` are each other's "
"reflection, and :meth:`__eq__` and :meth:`__ne__` are their own "
"reflection. If the operands are of different types, and right operand's "
"type is a direct or indirect subclass of the left operand's type, the "
"reflected method of the right operand has priority, otherwise the left "
"operand's method has priority.  Virtual subclassing is not considered."
msgstr ""
"이 메쏘드들에 대한 (왼편의 인자는 연산을 지원하지 않지만 오른편 인자가 지원할 때 사용되는)뒤집힌 "
"버전은 따로 없다; 대신에 :meth:`__lt__` 와 :meth:`__gt__` 는 서로의 뒤집힌 연산이다; "
":meth:`__le__` 와 :meth:`__ge__` 는 서로의 뒤집힌 연산이다; :meth:`__eq__` 와 "
":meth:`__ne__` 는 서로의 뒤집힌 연산이다; 만약 피연산자가 서로 다른 형이고, 오른편 "
"피연산자의 형이 원편 피연산의의 형의 직간접적인 서브클래스면, 오른편 피연산자의 뒤집힌 버전이 "
"우선순위가 높다; 그렇지 않으면 왼편 피연산자의 메쏘드가 우선순위가 높다. 가상 서브클래싱"
"(virtual subclassing)은 고려되지 않는다."

#: ../Doc/reference/datamodel.rst:1338
msgid ""
"Called by built-in function :func:`hash` and for operations on members of"
" hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of"
" the object that also play a part in comparison of objects by packing "
"them into a tuple and hashing the tuple. Example::"
msgstr ""
"내장 함수 :func:`hash` 와 :class:`set`, :class:`frozenset`, :class:`dict` 와 "
"같은 해시형 컬렉션의 멤버에 대한 연산에서 호출된다. :meth:`__hash__` 는 정수를 돌려줘야 "
"한다. 같다고 비교되는 객체들이 같은 해시 값을 가져야 한다는 성질만 요구된다. 객체의 비교에 "
"사용되는 요소들로 튜플을 구성하고, 그 튜플의 해시값을 취함으로써 요소들의 해시값을 섞는 것을 "
"권한다. 예를 들면::"

#: ../Doc/reference/datamodel.rst:1351
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way "
"to do this is with ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` 는 객체가 정의한 :meth:`__hash__` 메쏘드가 돌려주는 값을 "
":c:type:`Py_ssize_t` 의 크기로 자른다(truncate). 이 것은 보통 64비트 빌드에서는 "
"8바이트고, 32비트 빌드에서는 4바이트다. 만약 객체의 :meth:`__hash__` 가 서로 다른 비트 "
"크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 빌드들에서의 폭을 검사해야 한다. "
"이렇게하는 쉬운 방법은 ``python -c \"import sys; print(sys.hash_info.width)\"``"
" 이다."

#: ../Doc/reference/datamodel.rst:1359
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define "
"a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not"
" :meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since "
"the implementation of hashable collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the"
" wrong hash bucket)."
msgstr ""
"만약 클래스가 :meth:`__eq__` 를 정의하지 않으면 :meth:`__hash__` 역시 정의하지 말아야 "
"한다. 만약 :meth:`__eq__` 를 정의하지만 :meth:`__hash__` 를 정의하지 않는다면, 그 "
"것의 인스턴스는 해서형 컬렉션에서 사용될 수 없다. 만약 클래스가 가변형 객체를 정의하고 있고 "
":meth:`__eq__` 를 구현한다면, :meth:`__hash__` 를 구현하지 말아야 하는데, 해시형 "
"컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 때문이다(만약 객체의 해시 값이 변하면, "
"잘못된 해시 버킷(hash bucket)에 있게 된다)."

#: ../Doc/reference/datamodel.rst:1368
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) "
"and ``x.__hash__()`` returns an appropriate value such that ``x == y`` "
"implies both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"사용자 정의 클래스는 기본적으로 :meth:`__eq__` 와 :meth:`__hash__` 메쏘드를 갖는다; "
"모든 객체들은 (자기 자신을 제외하고) 같지 않다고 비교되고, ``x.__hash__()`` 는 적절한 값을 "
"돌려주어, ``x == y`` 일 때 ``x is y`` 와 ``hash(x) == hash(y)`` 가 동시에 성립할 "
"수 있도록 한다."

#: ../Doc/reference/datamodel.rst:1373
msgid ""
"A class that overrides :meth:`__eq__` and does not define "
":meth:`__hash__` will have its :meth:`__hash__` implicitly set to "
"``None``.  When the :meth:`__hash__` method of a class is ``None``, "
"instances of the class will raise an appropriate :exc:`TypeError` when a "
"program attempts to retrieve their hash value, and will also be correctly"
" identified as unhashable when checking ``isinstance(obj, "
"collections.Hashable)``."
msgstr ""
":meth:`__eq__` 를 재정의하고 :meth:`__hash__` 를 정의하지 않는 클래스는 "
":meth:`__hash__` 가 ``None`` 으로 설정된다. 클래스의 :meth:`__hash__` 메쏘드가 "
"``None`` 이면, 클래스의 인스턴스는 프로그램이 해시 값을 얻으려 시도할때 :exc:`TypeError` "
"를 일으키고, ``isinstance(obj, collections.Hashable)`` 로 검사할 때 해시가능하지 "
"않다고 올바로 감지된다."

#: ../Doc/reference/datamodel.rst:1380
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the "
"implementation of :meth:`__hash__` from a parent class, the interpreter "
"must be told this explicitly by setting ``__hash__ = "
"<ParentClass>.__hash__``."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하는 클래스가 부모 클래스로부터 :meth:`__hash__` 의 "
"구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 한다: ``__hash__ = "
"<ParentClass>.__hash__``."

#: ../Doc/reference/datamodel.rst:1384
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A"
" class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.Hashable)`` call."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 "
"``__hash__ = None`` 을 포함시켜야 한다. 자신의 :meth:`__hash__` 을 정의한 후에 직접 "
":exc:`TypeError` 를 일으키는 경우는 ``isinstance(obj, collections.Hashable)`` "
"호출에 의해 해시가능하다고 잘못 인식된다."

#: ../Doc/reference/datamodel.rst:1393
msgid ""
"By default, the :meth:`__hash__` values of str, bytes and datetime "
"objects are \"salted\" with an unpredictable random value.  Although they"
" remain constant within an individual Python process, they are not "
"predictable between repeated invocations of Python."
msgstr ""
"기본적으로, str, bytes, datetime 객체들의 :meth:`__hash__` 값은 예측할 수 없는 "
"난수값으로 \"솔트되어(salted)\" 있다. 개별 파이썬 프로세스내에서는 변하지 않는 값으로 "
"유지되지만, 파이썬을 반복 적으로 실행할 때는 예측할 수 없게 된다."

#: ../Doc/reference/datamodel.rst:1398
msgid ""
"This is intended to provide protection against a denial-of-service caused"
" by carefully-chosen inputs that exploit the worst case performance of a "
"dict insertion, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"이 것은 dict 삽입의 최악의 경우 성능(worst case performance), O(n^2) 복잡도, 을 "
"활용하기 위해 주의깊게 선택한 입력에 의한 서비스 거부(denial-of-service) 공격에 대한 "
"방어를 제공하기 위한 목적이다. 자세한 내용은 "
"http://www.ocert.org/advisories/ocert-2011-003.html 에 있다."

#: ../Doc/reference/datamodel.rst:1403
msgid ""
"Changing hash values affects the iteration order of dicts, sets and other"
" mappings.  Python has never made guarantees about this ordering (and it "
"typically varies between 32-bit and 64-bit builds)."
msgstr ""
"해시 값의 변경은 딕셔너리와 집합과 그밖의 다른 매핑들의 순환(iteration) 순서에 영향을 준다, "
"파이썬은 이 순서에 대한 어떤 보장도 하지 않는다 (그리고 보통 32비트와 64비트 빌드 사이에서도 "
"다르다)."

#: ../Doc/reference/datamodel.rst:1407
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` 를 참고하라."

#: ../Doc/reference/datamodel.rst:1409
msgid "Hash randomization is enabled by default."
msgstr "해시 난수화는 기본적으로 활성화된다."

#: ../Doc/reference/datamodel.rst:1417
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not"
" defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither "
":meth:`__len__` nor :meth:`__bool__`, all its instances are considered "
"true."
msgstr ""
"논리값 검사와 내장 연산 ``bool()`` 구현을 위해 호출된다; ``False`` 나 ``True`` 를 "
"돌려줘야 한다. 이 메쏘드가 정의되지 않는 경우, 정의되어 있다면 :meth:`__len__` 이 "
"호출되어, 값이 0 이 아니면 참으로 인식한다. 만약 클래스가 :meth:`__len__` 과 "
":meth:`__bool__` 모두 정의하지 않는다면, 모든 인스턴스는 참으로 취급된다."

#: ../Doc/reference/datamodel.rst:1428
msgid "Customizing attribute access"
msgstr "어트리뷰트 액세스 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1430
msgid ""
"The following methods can be defined to customize the meaning of "
"attribute access (use of, assignment to, or deletion of ``x.name``) for "
"class instances."
msgstr ""
"클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, ``x.name`` 을 삭제하기)의 의미를 변경하기 "
"위해 다음과 같은 메쏘드들이 정의될 수 있다."

#: ../Doc/reference/datamodel.rst:1438
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class"
" tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""
"일반적인 장소에서 어트리뷰트가 발견되지 않을 때 호출된다(즉, 인스턴스 어트리뷰트도 아니고 "
"``self`` 의 클래스 트리에서도 발견되지 않을때). ``name`` 은 어트리뷰트의 이름이다. 이 "
"메쏘드는 어트리뷰트의 (계산된) 값을 돌려주거나 :exc:`AttributeError` 예외를 일으켜야 한다."

#: ../Doc/reference/datamodel.rst:1443
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both "
"for efficiency reasons and because otherwise :meth:`__getattr__` would "
"have no way to access other attributes of the instance.  Note that at "
"least for instance variables, you can fake total control by not inserting"
" any values in the instance attribute dictionary (but instead inserting "
"them in another object).  See the :meth:`__getattribute__` method below "
"for a way to actually get total control over attribute access."
msgstr ""
"일반적인 기작(mechanism)을 통해 어트리뷰트가 발견되면 :meth:`__getattr__` 이 호출되지 "
"않음에 주의해야 한다 (이 것은 :meth:`__getattr__` 과 :meth:`__setattr__` 간의 "
"의도된 비대칭이다). 이렇게 하는 이유는 효율 때문이기도 하고, 그렇게 하지 않을 경우 "
":meth:`__getattr__` 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 때문이기도 하다. "
"적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그 "
"것들을 다른 객체에 넣는다) 완전한 제어인 것처럼 조작할 수 있다. 어트리뷰트 액세스를 실제로 "
"완전히 조작하는 방법에 대해서는 아래에 나오는 :meth:`__getattribute__` 에서 다룬다."

#: ../Doc/reference/datamodel.rst:1456
msgid ""
"Called unconditionally to implement attribute accesses for instances of "
"the class. If the class also defines :meth:`__getattr__`, the latter will"
" not be called unless :meth:`__getattribute__` either calls it explicitly"
" or raises an :exc:`AttributeError`. This method should return the "
"(computed) attribute value or raise an :exc:`AttributeError` exception. "
"In order to avoid infinite recursion in this method, its implementation "
"should always call the base class method with the same name to access any"
" attributes it needs, for example, ``object.__getattribute__(self, "
"name)``."
msgstr ""
"클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건없이 호출된다. 만약 클래스가 "
":meth:`__getattr__` 도 함께 구현하면, :meth:`__getattribute__` 가 명시적으로 "
"호출하거나 :exc:`AttributeError` 를 일으키지 않는 이상 `__getattr__` 는 "
"호출되지 않는다. 이 메쏘드는 어트리뷰트의 (계산된) 값을 돌려주거나 :exc:`AttributeError` "
"예외를 일으켜야 한다. 이 메쏘드에서 무한 재귀(infinite recursion)가 발생하는 것을 "
"막기위해, 구현은 반드시 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스클래스의 메쏘드를 "
"호출해야 한다. 예를들어, ``object.__getattribute__(self, name)``."

#: ../Doc/reference/datamodel.rst:1467
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""
"언어 문법이나 내장 함수에 의한 암묵적인 호출이 결과로 특수 메쏘드를 참조하는 경우에는 이 메쏘드를 거치지 않을 수 있다. 자세한 내용은 :ref:`special-lookup` 에서 다룬다."

#: ../Doc/reference/datamodel.rst:1474
msgid ""
"Called when an attribute assignment is attempted.  This is called instead"
" of the normal mechanism (i.e. store the value in the instance "
"dictionary). *name* is the attribute name, *value* is the value to be "
"assigned to it."
msgstr ""
"어트리뷰트 대입이 시도될 때 호출된다. 일반적인 기작(즉 인스턴스 딕셔너리에 값을 저장하는 것) "
"대신에 이 것이 호출된다. *name* 은 어트리뷰트 이름이고, *value* 는 그 것에 대입하려는 "
"값이다. "

#: ../Doc/reference/datamodel.rst:1478
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it "
"should call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` 에서 인스턴스 어트리뷰트에 대입하려고할 때는, 같은 이름의 "
"베이스클래스의 메쏘드를 호출해야 한다. 예를 들어 ``object.__setattr__(self, name, "
"value)``"

#: ../Doc/reference/datamodel.rst:1485
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of "
"assignment.  This should only be implemented if ``del obj.name`` is "
"meaningful for the object."
msgstr ""
":meth:`__setattr__` 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제한다. 이 것은 "
"``del obj.name`` 이 객체에 의미가 있는 경우에만 구현되어야 한다."

#: ../Doc/reference/datamodel.rst:1491
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts "
"it."
msgstr ""
"객체에 :func:`dir` 이 호출될 때 호출된다. 시퀀스를 돌려줘야 한다. :func:`dir` 은 돌려준 "
"시퀀스를 리스트로 변환한 후 정렬한다."

#: ../Doc/reference/datamodel.rst:1498
msgid "Implementing Descriptors"
msgstr "디스크립터 구현하기"

#: ../Doc/reference/datamodel.rst:1500
msgid ""
"The following methods only apply when an instance of the class containing"
" the method (a so-called *descriptor* class) appears in an *owner* class "
"(the descriptor must be in either the owner's class dictionary or in the "
"class dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property"
" in the owner class' :attr:`~object.__dict__`."
msgstr ""
"다음에 오는 메쏘드들은 메쏘드를 갖고 있는 클래스(소위 *디스크립터(descriptor)*클래스)의 "
"인스턴스가 *소유자(owner)* 클래스에 등장할 때만 적용된다(디스크립터는 소유자 클래스의 "
"딕셔너리나 그 부모 클래스들중 하나의 딕셔너리에 있어야 한다). 아래의 예에서, \"어트리뷰트\" 는 "
"이름이 소유자 클래스의 :attr:`~object.__dict__` 의 키로 사용되고 있는 어트리뷰트를 "
"가리킨다."

#: ../Doc/reference/datamodel.rst:1510
msgid ""
"Called to get the attribute of the owner class (class attribute access) "
"or of an instance of that class (instance attribute access). *owner* is "
"always the owner class, while *instance* is the instance that the "
"attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*.  This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 "
"어트리뷰트를 취하려고 할 때 호출된다. *owner* 는 항상 소유자 클래스다. 반면에 *instance* "
"는 어트리뷰트 참조가 일어나고 있는 인스턴스이거나, 어트리뷰트가 *owner* 를 통해 액세스되는 경우 "
"`None` 이다. 이 메쏘드는 (계산된) 어트리뷰트 값을 돌려주거나 :exc:`AttributeError` "
"예외를 일으켜야 한다."

#: ../Doc/reference/datamodel.rst:1520
msgid ""
"Called to set the attribute on an instance *instance* of the owner class "
"to a new value, *value*."
msgstr ""
"소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 새 값 *value* 로 설정할 때 호출된다."

#: ../Doc/reference/datamodel.rst:1526
msgid ""
"Called to delete the attribute on an instance *instance* of the owner "
"class."
msgstr ""
"소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 삭제할 때 호출된다."

#: ../Doc/reference/datamodel.rst:1531
msgid ""
"Called at the time the owning class *owner* is created. The descriptor "
"has been assigned to *name*."
msgstr ""
"소유자 클래스 *owner* 가 만들어질 때 호출된다. 이 디스크립터가 *name* 에 대입되었다."

#: ../Doc/reference/datamodel.rst:1537
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting "
"this appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given"
" type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods "
"that are implemented in C)."
msgstr ""
"어트리뷰트 :attr:`__objclass__` 는 :mod:`inspect` 모듈에 의해 이 객체가 정의된 "
"클래스를 지정하는 것으로 해석된다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 "
"인트로스펙션(introspection)을 지원할 수 있다). 콜러블의 경우, 첫번째 위치 지정 인자에, "
"주어진 형(또는 서브클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 있다(예를 들어, CPython "
"은 C 로 구현된 연결되지 않은 메쏘드(unbound method)에 이 어트리뷰트를 설정한다)."

#: ../Doc/reference/datamodel.rst:1548
msgid "Invoking Descriptors"
msgstr "디스크립터 호출하기"

#: ../Doc/reference/datamodel.rst:1550
msgid ""
"In general, a descriptor is an object attribute with \"binding "
"behavior\", one whose attribute access has been overridden by methods in "
"the descriptor protocol:  :meth:`__get__`, :meth:`__set__`, and "
":meth:`__delete__`. If any of those methods are defined for an object, it"
" is said to be a descriptor."
msgstr ""
"일반적으로, 디스크립터는 \"결합된 동작(binding behavior)\"를 갖고 있는 객체 어트리뷰트다. "
"어트리뷰트 액세스가 디스크립터 프로토콜(descriptor protocol)의 메쏘드들에 의해 재정의된다: "
":meth:`__get__`, :meth:`__set__`, :meth:`__delete__`. 이 메쏘드들 중 하나라도 "
"정의되어 있으면, 디스크립터라고 부른다."

#: ../Doc/reference/datamodel.rst:1555
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup"
" chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``,"
" and continuing through the base classes of ``type(a)`` excluding "
"metaclasses."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것이다. "
"예를 들어 ``a.x`` 는 ``a.__dict__['x']`` 에서 시작해서 ``type(a).__dict__['x']``"
" 를 거쳐 ``type(a)`` 의 메타클래스를 제외한 베이스 클래스들을 거쳐가는 일련의 조회로 구성된다."

#: ../Doc/reference/datamodel.rst:1560
msgid ""
"However, if the looked-up value is an object defining one of the "
"descriptor methods, then Python may override the default behavior and "
"invoke the descriptor method instead.  Where this occurs in the "
"precedence chain depends on which descriptor methods were defined and how"
" they were called."
msgstr ""
"그러나, 만약 조회한 값이 디스크립터 메쏘드를 구현한 객체면, 파이썬은 기본 동작대신에 디스크립터 "
"메쏘드를 호출할 수 있다. 우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 "
"메쏘드가 정의되어 있고 어떤 식으로 호출되는지에 따라 다르다."

#: ../Doc/reference/datamodel.rst:1565
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How "
"the arguments are assembled depends on ``a``:"
msgstr ""
"디스크립터 호출의 시작점은 결합(binding)이다, ``a.x``. 어떻데 인자들이 조합되는지는 ``a`` "
"에 따라 다르다:"

#: ../Doc/reference/datamodel.rst:1570
msgid "Direct Call"
msgstr "직접 호출"

#: ../Doc/reference/datamodel.rst:1569
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메쏘드를 직접 호출할 때다: "
"``x.__get__(a)``"

#: ../Doc/reference/datamodel.rst:1574
msgid "Instance Binding"
msgstr "인스턴스 결합"

#: ../Doc/reference/datamodel.rst:1573
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"객체 인스턴스에 결합되면, ``a.x`` 는 이런 호출로 변환된다: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

#: ../Doc/reference/datamodel.rst:1578
msgid "Class Binding"
msgstr "클래스 결합"

#: ../Doc/reference/datamodel.rst:1577
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr ""
"클래스에 결합되면, ``A.x`` 는 이런 호출로 변환된다: "
"``A.__dict__['x'].__get__(None, A)``."

#: ../Doc/reference/datamodel.rst:1584
msgid "Super Binding"
msgstr "Super 결합"

#: ../Doc/reference/datamodel.rst:1581
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the "
"call: ``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
":class:`super` 의 인스턴스에 결합되면, 결합 ``super(B, obj).m()`` 은 "
"``obj.__class__.__mro__`` 를 검색해서 ``B`` 바로 다음에 나오는 베이스 클래스 ``A`` "
"를 찾은 후에 이렇게 호출한다: ``A.__dict__['m'].__get__(obj, obj.__class__)``."

#: ../Doc/reference/datamodel.rst:1586
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on"
" the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  "
"If it does not define :meth:`__get__`, then accessing the attribute will "
"return the descriptor object itself unless there is a value in the "
"object's instance dictionary.  If the descriptor defines :meth:`__set__` "
"and/or :meth:`__delete__`, it is a data descriptor; if it defines "
"neither, it is a non-data descriptor.  Normally, data descriptors define "
"both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have"
" just the :meth:`__get__` method.  Data descriptors with :meth:`__set__` "
"and :meth:`__get__` defined always override a redefinition in an instance"
" dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"인스턴스 결합의 경우, 디스크립터 호출의 우선순위는 어떤 디스크립터 메쏘드가 정의되어있는지에 따라 "
"다르다. 디스크립터는 :meth:`__get__`, :meth:`__set__`, :meth:`__delete__` 를 "
"어떤 조합으로도 정의할 수 있다. 만약 :meth:`__get__` 를 정의하지 않는다면, 어트리뷰트 "
"액세스는, 객체의 인스턴스 딕셔너리에 값이 있지 않은이상 디스크립터 객체 자신을 돌려준다. 만약 "
"디스크립터가 :meth:`__set__` 이나 :meth:`__delete__` 중 어느 하나나 둘 모두 "
"정의하면, 데이터 디스크립터(data descriptor)다. 둘 다 정의하지 않는다면 비데이터 "
"디스크립터다(non-data descriptor).  보통, 데이터 디스크립터가 :meth:`__get__` 과 "
":meth:`__set__` 을 모두 정의하는 반면, 비데이터 디스크립터는 :meth:`__get__` 메쏘드만 "
"정의한다. :meth:`__set__` 과 :meth:`__get__` 이 있는 데이터 디스크립터는 이스턴스 "
"딕셔너리에 있는 값에 우선한다. 반면에 비데이터 디스크립터는 인스턴스보다 우선 순위가 낮다."

#: ../Doc/reference/datamodel.rst:1599
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) "
"are implemented as non-data descriptors.  Accordingly, instances can "
"redefine and override methods.  This allows individual instances to "
"acquire behaviors that differ from other instances of the same class."
msgstr ""
"파이썬 메쏘드 (:func:`staticmethod` 와 :func:`classmethod` 를 포함해서) 는 "
"비데이터 디스크립터로 구현된다. 이 때문에, 인스턴스는 메쏘드를 새로 정의하거나 덮어쓸 수 있다. "
"이 것은 개별 인스턴스가 같은 클래스의 다른 인스턴스들과는 다른 동작을 얻을 수 있도록 만든다."

#: ../Doc/reference/datamodel.rst:1604
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` 함수는 데이터 디스크립터로 구현된다. 이 때문에, 인스턴스는 프라퍼티"
"(property)의 동작을 변경할 수 없다."

#: ../Doc/reference/datamodel.rst:1611
msgid "__slots__"
msgstr ""

#: ../Doc/reference/datamodel.rst:1613
msgid ""
"By default, instances of classes have a dictionary for attribute storage."
"  This wastes space for objects having very few instance variables.  The "
"space consumption can become acute when creating large numbers of "
"instances."
msgstr ""
"기본적으로, 클래스의 인스턴스는 어트리뷰트를 저장하기 위한 딕셔너리를 갖는다. 아주 적은 개수의 "
"인스턴스 변수를 갖는 경우 이 것은 객체들의 저장 공간을 낭비하도록 한다. 많은 수의 인스턴스를 "
"만들 때 이 공간 소비는 심각해질 수있다."

#: ../Doc/reference/datamodel.rst:1617
msgid ""
"The default can be overridden by defining *__slots__* in a class "
"definition. The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value"
" for each variable.  Space is saved because *__dict__* is not created for"
" each instance."
msgstr ""
"이런 기본 동작은 클래스 정의에 *__slots__* 를 정의함으로써 바꿀 수 있다. *__slots__* "
"선언은 인스턴스 변수의 시퀀스를 받아서 각 인스턴스에 각 변수의 값들을 저장하는데 딱 필요한 만큼의 "
"공간만을 예약한다. 각 인스턴스마다 *__dict__* 가 만들어지지 않기 때문에 공간이 절약된다."

#: ../Doc/reference/datamodel.rst:1625
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves "
"space for the declared variables and prevents the automatic creation of "
"*__dict__* and *__weakref__* for each instance."
msgstr ""
"이 클래스 변수에는 인스턴스에 의해 사용되는 변수들의 이름을 제공하는 문자열, 이터러블(iterable)"
", 문자열의 시퀀스가 대입될 수 있다. *__slots__* 은 선언된 변수들을 위한 공간을 예약하고, 간 "
"인스턴스마다 *__dict__* 와 *__weakref__* 가 만들어지는 것을 막는다. "

#: ../Doc/reference/datamodel.rst:1632
msgid "Notes on using *__slots__*"
msgstr "*__slots__* 사용에 관한 노트"

#: ../Doc/reference/datamodel.rst:1634
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* "
"attribute of that class will always be accessible, so a *__slots__* "
"definition in the subclass is meaningless."
msgstr ""
"*__slots__* 가 없는 클래스를 계승할 때, 클래스의 *__dict__* 어트리뷰트는 항상 제공되기 "
"때문에, 서브클래스의 *__slots__* 정의는 의미를 잃는다."

#: ../Doc/reference/datamodel.rst:1638
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables"
" not listed in the *__slots__* definition.  Attempts to assign to an "
"unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"*__dict__* 변수가 없기때문에, 인스턴스는 *__slots__* 정의에 나열되지 않은 새 변수를 "
"대입할 수 없다. 나열되지 않은 변수명으로 대입하려고 하면 :exc:`AttributeError` 를 "
"일으킨다. 만약 동적으로 새 변수를 대입하는 것이 필요하다면, *__slots__* 선언의 문자열 "
"시퀀스에 ``'__dict__'`` 를 추가한다."

#: ../Doc/reference/datamodel.rst:1644
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence "
"of strings in the *__slots__* declaration."
msgstr ""
"인스턴스마다 *__weakref__* 변수가 없기 때문에, *__slots__* 를 정의하는 클래스는 "
"인스턴스에 대한 약한 참조(weak reference)를 지원하지 않는다. 만약 약한 참조 지원이 "
"필요하다면, *__slots__* 선언의 문자열 시퀀스에 ``'__weakref__'`` 를 추가한다."

#: ../Doc/reference/datamodel.rst:1649
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class "
"attributes cannot be used to set default values for instance variables "
"defined by *__slots__*; otherwise, the class attribute would overwrite "
"the descriptor assignment."
msgstr ""
"*__slots__* 는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 구현된다"
"(:ref:`descriptors`). 결과적으로, 클래스 어트리뷰트는 *__slots__* 로 정의된 인스턴스 "
"변수들을 위한 기본값을 제공할 목적으로 사용될 수 없다. 클래스 어트리뷰트는 디스크립터 대입을 "
"무효화한다."

#: ../Doc/reference/datamodel.rst:1655
msgid ""
"The action of a *__slots__* declaration is limited to the class where it "
"is defined.  As a result, subclasses will have a *__dict__* unless they "
"also define *__slots__* (which must only contain names of any "
"*additional* slots)."
msgstr ""
"*__slots__* 선언으로 인한 효과는 그 것이 정의된 클래스로 한정된다. 결과적으로, 서브클래스가 "
"자신의 *__slots__* (새로 *추가되는* 변수들만 포함해야 한다) 을 정의하지 않는다면 "
"*__dict__* 를 갖게 된다."

#: ../Doc/reference/datamodel.rst:1659
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the"
" meaning of the program undefined.  In the future, a check may be added "
"to prevent this."
msgstr ""
"클래스가 베이스 클래스의 *__slots__* 에 정의된 이름과 같은 이름의 변수를 *__slots__* 에 "
"선언한다면, 베이스 클래스가 정의한 변수는 앤세스할 수 없는 상태가 된다(베이스클래스로부터 "
"디스크립터를 직접 조회하는 경우는 예외다). 이 것은 프로그램을 정의되지 않은 상태로 보내게된다. "
"미래에는, 이를 방지하기 위한 검사가 추가될 것이다."

#: ../Doc/reference/datamodel.rst:1664
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and "
":class:`tuple`."
msgstr ""
":class:`int`, :class:`bytes`, :class:`tuple` 과 같은 \"가변 길이"
"(valiable-length)\" 의 내장 형들을 계승하는 클래스에서는 오직 빈 *__slots__* 만 "
"지원된다."

#: ../Doc/reference/datamodel.rst:1667
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also"
" be used; however, in the future, special meaning may be assigned to the "
"values corresponding to each key."
msgstr ""
"*__slots__* 에는 문자열 이외의 이터러블을 대입할 수 있다. 매핑도 역시 사용할 수 있다. "
"하지만, 미래에, 각 키에 대응하는 값들의 의미가 부여될 수 있다."

#: ../Doc/reference/datamodel.rst:1671
msgid ""
"*__class__* assignment works only if both classes have the same "
"*__slots__*."
msgstr ""
"두 클래스들이 같은 *__slots__* 을 갖는 경우만 *__class__* 대입이 동작한다."

#: ../Doc/reference/datamodel.rst:1677
msgid "Customizing class creation"
msgstr "클래스 생성 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1679
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is "
"called on that class. This way, it is possible to write classes which "
"change the behavior of subclasses. This is closely related to class "
"decorators, but where class decorators only affect the specific class "
"they're applied to, ``__init_subclass__`` solely applies to future "
"subclasses of the class defining the method."
msgstr ""
"클래스가 다른 클래스를 상속할 때, 그 클래스의 *__init_subclass__* 가 호출된다. 이 "
"방법으로, 서브클래스의 동작을 변경하는 클래스를 쓰는 것이 가능하다. 이런 용도는 클래스 "
"데코레이터와도 밀접히 관련되어 있다. 하지만 클래스 데코레이터는 그들을 사용하는 특정한 클래스에만 "
"작용하지만, ``__init_subclass__`` 단독으로 그 메쏘드를 정의하는 클래스의 미래의 서브클래스 "
"모두에게 작용한다."

#: ../Doc/reference/datamodel.rst:1688
msgid ""
"This method is called whenever the containing class is subclassed. *cls* "
"is then the new subclass. If defined as a normal instance method, this "
"method is implicitly converted to a class method."
msgstr ""
"이 메쏘드는 포함하는 클래스의 서브클래스가 만들어질 때 마다 호출된다. *cls* 는 새 "
"서브클래스다. 만약 일반적인 인스턴스 메쏘드로 정의되면, 이 메쏘드는 암묵적으로 클래스 메쏘드로 "
"변경된다."

#: ../Doc/reference/datamodel.rst:1692
msgid ""
"Keyword arguments which are given to a new class are passed to the "
"parent's class ``__init_subclass__``. For compatibility with other "
"classes using ``__init_subclass__``, one should take out the needed "
"keyword arguments and pass the others over to the base class, as in::"
msgstr ""
"새 클래스에 주어진 키워드 인자들은 부모 클래스의 ``__init_subclass__`` 로 전달된다. "
"``__init_subclass__`` 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 인자들을 꺼낸 "
"후에 다른 것들을 베이스 클래스로 전달해야 한다. 이런식이다::"

#: ../Doc/reference/datamodel.rst:1706
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but"
" raises an error if it is called with any arguments."
msgstr ""
"기본 구현 ``object.__init_subclass__`` 는 아무일도 하지 않지만, 인자가 포함되어 "
"호출되면 예외를 발생시킨다."

#: ../Doc/reference/datamodel.rst:1711
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. "
"The actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"메타클래스 힌트 ``metaclass`` 는 나머지 형 기작에 의해 소비되고, ``__init_subclass__``"
" 로 전달되지 않는다. 실제 메타클래스 (명시적인 힌트 대신에) 는  ``type(cls)`` 로 액세스할 "
"수 있다."

#: ../Doc/reference/datamodel.rst:1722
msgid "Metaclasses"
msgstr "메타클래스"

#: ../Doc/reference/datamodel.rst:1728
msgid ""
"By default, classes are constructed using :func:`type`. The class body is"
" executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"기본적으로, 클래스는 :func:`type` 을 사용해서 만들어진다. 클래스의 바디는 새 이름공간에서 "
"실행되고, 클래스 이름은 ``type(name, bases, namespace)`` 의 결과에 지역적으로 연결된다."

#: ../Doc/reference/datamodel.rst:1732
msgid ""
"The class creation process can be customized by passing the ``metaclass``"
" keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"클래스를 만드는 과정은 클래스 정의 줄에 ``metaclass`` 키워드 인자를 전달하거나, 그런 인자를 "
"포함한 이미 존재하는 클래스를 계승함으로써 커스터마이즈될 수 있다. 다음 예에서, ``MyClass`` "
"와 ``MySubclass`` 는 모두 ``Meta`` 의 인스턴스다."

#: ../Doc/reference/datamodel.rst:1746
msgid ""
"Any other keyword arguments that are specified in the class definition "
"are passed through to all metaclass operations described below."
msgstr ""
"클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타클래스 연산들로 전달된다."

#: ../Doc/reference/datamodel.rst:1749
msgid "When a class definition is executed, the following steps occur:"
msgstr "클래스 정의가 실행될 때, 다음과 같은 단계가 수행된다.:"

#: ../Doc/reference/datamodel.rst:1751
msgid "the appropriate metaclass is determined"
msgstr "적절한 메타클래스가 결정된다"

#: ../Doc/reference/datamodel.rst:1752
msgid "the class namespace is prepared"
msgstr "클래스 이름공간이 준비된다"

#: ../Doc/reference/datamodel.rst:1753
msgid "the class body is executed"
msgstr "클래스 바디가 실행된다"

#: ../Doc/reference/datamodel.rst:1754
msgid "the class object is created"
msgstr "클래스 객체가 만들어진다"

#: ../Doc/reference/datamodel.rst:1757
msgid "Determining the appropriate metaclass"
msgstr "적절한 메타클래스 선택하기"

#: ../Doc/reference/datamodel.rst:1761
msgid "The appropriate metaclass for a class definition is determined as follows:"
msgstr "클래스 정의의 적절한 메타클래스는 다음과 같이 결정된다:"

#: ../Doc/reference/datamodel.rst:1763
msgid "if no bases and no explicit metaclass are given, then :func:`type` is used"
msgstr "베이스와 명시적인 메타클래스가 주어지지 않는 경우 :func:`type` 이 사용된다"

#: ../Doc/reference/datamodel.rst:1764
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass"
msgstr ""
"명시적인 메타클래스가 지정되고, 그 것이 :func:`type` 의 인스턴스가 *아니면*, 그 것을 "
"메타클래스로 사용한다"

#: ../Doc/reference/datamodel.rst:1766
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or "
"bases are defined, then the most derived metaclass is used"
msgstr ""
":func:`type` 의 인스턴스가 명시적인 메타클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타클래스가 사용된다"

#: ../Doc/reference/datamodel.rst:1769
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all "
"specified base classes. The most derived metaclass is one which is a "
"subtype of *all* of these candidate metaclasses. If none of the candidate"
" metaclasses meets that criterion, then the class definition will fail "
"with ``TypeError``."
msgstr ""
"가장 많이 파생된 메타클래스는 명시적으로 지정된 메타클래스(있다면) 와 지정된 모든 베이스 "
"클래스들의 메타클래스들(즉, ``type(cls)``) 중에서 선택된다. 가장 많이 파생된 메타클래스는 "
"이들 모두의 서브타입(subtype)이다. 만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 "
"``TypeError`` 를 발생시키며 실패한다."

#: ../Doc/reference/datamodel.rst:1779
msgid "Preparing the class namespace"
msgstr "클래스 이름공간 준비하기"

#: ../Doc/reference/datamodel.rst:1784
msgid ""
"Once the appropriate metaclass has been identified, then the class "
"namespace is prepared. If the metaclass has a ``__prepare__`` attribute, "
"it is called as ``namespace = metaclass.__prepare__(name, bases, "
"**kwds)`` (where the additional keyword arguments, if any, come from the "
"class definition)."
msgstr ""
"일단 적절한 메타클래스가 식별되면, 클래스 이름공간이 준비된다. 만약 메타클래스가 "
"``__prepare__`` 어트리뷰트를 가지면, "
"``namespace = metaclass.__prepare__(name, bases, **kwds)`` 같은 식으로 "
"호출된다(추가적인 키워드 인자가 있다면 클래스 정의에서 온 것이다)."

#: ../Doc/reference/datamodel.rst:1789
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class "
"namespace is initialised as an empty ordered mapping."
msgstr ""
"만약 메타클래스에 ``__prepare__`` 어트리뷰트가 없다면, 클래스 이름공간은 빈 순서있는 "
"매핑(ordered mapping) 으로 초기화된다."

#: ../Doc/reference/datamodel.rst:1794
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - 파이썬 3000 에서의 메타클래스"

#: ../Doc/reference/datamodel.rst:1795
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` 이름공간 훅을 도입했다"

#: ../Doc/reference/datamodel.rst:1799
msgid "Executing the class body"
msgstr "클래스 바디 실행하기"

#: ../Doc/reference/datamodel.rst:1804
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is "
"that lexical scoping allows the class body (including any methods) to "
"reference names from the current and outer scopes when the class "
"definition occurs inside a function."
msgstr ""
"클래스 바디는 (대략) ``exec(body, globals(), namespace)`` 과 같이 실행된다. 일반적인 :func:`exec` 호출과의 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 구문 스코핑(lexical scoping) 이 클래스 바디(모든 메쏘드들을 포함해서)로 하여금 현재와 외부 스콥에 있는 이름들을 참조하도록 허락한다는 것이다."

#: ../Doc/reference/datamodel.rst:1810
msgid ""
"However, even when the class definition occurs inside the function, "
"methods defined inside the class still cannot see names defined at the "
"class scope. Class variables must be accessed through the first parameter"
" of instance or class methods, or through the implicit lexically scoped "
"``__class__`` reference described in the next section."
msgstr ""
"하지만, 클래스 정의가 함수 내부에서 이루어질때조차도, 클래스 내부에서 정의된 메쏘드들은 클래스 "
"스콥에서 정의된 이름들을 볼 수 없다. 클래스 변수는 인스턴스나 클래스 메쏘드의 첫번째 인자를 통해 "
"액세스하거나 다음 섹션에서 설명하는 암묵적으로 구문 스코핑된 ``__class__`` 참조를 통해야 한다."

#: ../Doc/reference/datamodel.rst:1819
msgid "Creating the class object"
msgstr "클래스 객체 만들기"

#: ../Doc/reference/datamodel.rst:1826
msgid ""
"Once the class namespace has been populated by executing the class body, "
"the class object is created by calling ``metaclass(name, bases, "
"namespace, **kwds)`` (the additional keywords passed here are the same as"
" those passed to ``__prepare__``)."
msgstr ""
"일단 클래스 이름공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 ``metaclass(name, "
"bases, namespace, **kwds)`` 을 통해 만들어진다(여기에서 전달되는 추가적인 키워드 "
"인자들은 ``__prepare__`` 에 전달된 것들과 같다)."

#: ../Doc/reference/datamodel.rst:1831
msgid ""
"This class object is the one that will be referenced by the zero-argument"
" form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on "
"lexical scoping, while the class or instance that was used to make the "
"current call is identified based on the first argument passed to the "
"method."
msgstr ""
"이 클래스 객체는 :func:`super` 에 인자를 주지 않는 경우 참조되는 것이다. ``__class__`` "
"는 클래스 바디의 메쏘드들 중 어느 하나라도 ``__class__`` 나 ``super`` 를 참조할 경우 "
"컴파일러에 의해 만들어지는 암묵적인 클로져(closure) 참조다. 이 것은 인자 없는 형태의 "
":func:`super` 가 구문 스코핑 기반으로 현재 정의되고 있는 클래스를 올바르게 찾을 수 있도록 "
"한다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메쏘드로 전달된 첫 번 째 인자에 기반해서 "
"식별된다."

#: ../Doc/reference/datamodel.rst:1841
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the "
"metaclass as a ``__classcell__`` entry in the class namespace. If "
"present, this must be propagated up to the ``type.__new__`` call in order"
" for the class to be initialised correctly. Failing to do so will result "
"in a :exc:`DeprecationWarning` in Python 3.6, and a :exc:`RuntimeWarning`"
" in the future."
msgstr ""
"CPython 3.6 이상에서, ``__class__`` 셀(cell) 은 클래스 이름공간의 "
"``__classcell__`` 엔트리로 메타클래스에 전달된다. 만약 존재한다면, 이 것은 클래스가 "
"올바르게 초기화되기 위해 ``type.__new__`` 호출까지 거슬러서 전파되어야 한다. 이렇게 하지 "
"못할 경우 파이썬 3.6 에서는 :exc:`DeprecationWarning` 이 발생하고, 미래에는 "
":exc:`RuntimeWarning` 이 될 것이다."

#: ../Doc/reference/datamodel.rst:1848
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation"
" steps are invoked after creating the class object:"
msgstr ""
"기본 메타클래스 :class:`type` 을 사용할 때나 다른 메타클래스가 결국 ``type.__new__`` "
"를 호출할 때, 클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행된다:"

#: ../Doc/reference/datamodel.rst:1852
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"첫째로, ``type.__new__`` 는 :meth:`~object.__set_name__` 을 정의하는 클래스 "
"이름공간의 모든 디스크립터들을 수집한다;"

#: ../Doc/reference/datamodel.rst:1854
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor; and"
msgstr ""
"둘째로, 이렇게 수집된 모든 ``__set_name__`` 을 호출하는데, 정의되고 있는 클래스와 "
"디스크립터에 주어진 이름을 인자로 전달한다; 그리고"

#: ../Doc/reference/datamodel.rst:1856
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""
"마지막으로, 메쏘드 검색 순서에 따라 가장 가까운 부모에대해 "
":meth:`~object.__init_subclass__` 훅 이 호출된다."

#: ../Doc/reference/datamodel.rst:1859
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is "
"bound in the local namespace as the defined class."
msgstr ""
"클래스 객체가 만들어진 후에, 클래스 정의에 포함된 데코레이터들에게 (있다면) 클래스를 전달하고, "
"그 결과를 클래스가 정의되는 지역 이름공간에 연결한다."

#: ../Doc/reference/datamodel.rst:1863
msgid ""
"When a new class is created by ``type.__new__``, the object provided as "
"the namespace parameter is copied to a new ordered mapping and the "
"original object is discarded. The new copy is wrapped in a read-only "
"proxy, which becomes the :attr:`~object.__dict__` attribute of the class "
"object."
msgstr ""
"``type.__new__`` 로 새 클래스가 만들어질 때, 이름공간 파라미터로 제공되는 객체는 새 "
"순서있는 매핑으로 복사되고, 원래의 객체는 버린다. 새 사본은 읽기전용 프락시(read-only "
"proxy)로 둘러싸이는데, 이 것이 클래스 객체의 :attr:`~object.__dict__` 어크리뷰트가 "
"된다."

#: ../Doc/reference/datamodel.rst:1870
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - 새 super"

#: ../Doc/reference/datamodel.rst:1871
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "암묵적인 \__class__ 클로져 참조를 설명한다"

#: ../Doc/reference/datamodel.rst:1875
msgid "Metaclass example"
msgstr "메타클래스 예제"

#: ../Doc/reference/datamodel.rst:1877
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have "
"been explored include enum, logging, interface checking, automatic "
"delegation, automatic property creation, proxies, frameworks, and "
"automatic resource locking/synchronization."
msgstr ""
"메타클래스의 잠재적인 용도에는 한계가 없다. 탐색된 몇가지 아이디어들에는 enum, 로깅, 인터페이스 "
"검사, 자동화된 위임(automatic delegation), 자동화된 프라퍼티(properety) 생성, "
"프락시(proxy), 프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource "
"locking/synchronization) 등이 있다."

#: ../Doc/reference/datamodel.rst:1882
msgid ""
"Here is an example of a metaclass that uses an "
":class:`collections.OrderedDict` to remember the order that class "
"variables are defined::"
msgstr ""
"여기, 클래스 변수가 정의된 순서를 기억하기위해 :class:`collections.OrderedDict` 를 사용하는 메타클래스의 예가 있다::"

#: ../Doc/reference/datamodel.rst:1905
msgid ""
"When the class definition for *A* gets executed, the process begins with "
"calling the metaclass's :meth:`__prepare__` method which returns an empty"
" :class:`collections.OrderedDict`.  That mapping records the methods and "
"attributes of *A* as they are defined within the body of the class "
"statement. Once those definitions are executed, the ordered dictionary is"
" fully populated and the metaclass's :meth:`__new__` method gets invoked."
"  That method builds the new type and it saves the ordered dictionary "
"keys in an attribute called ``members``."
msgstr ""
"*A* 의 클래스 정의가 실행될 때, 프로세스는 메타클래스의 :meth:`__prepare__` 를 호출하는 "
"것으로 시작하는데, 빈 :class:`collections.OrderedDict` 를 돌려준다. 이 매핑은 *A* "
"의 메쏘드와 어트리뷰트들을 클래스 문의 바디에 정의된데로 기록한다. 일단 그 정의들이 실행되면, "
"순서있는 딕셔너리는 모두 채워지고, 메타클래스의 :meth:`__new__` 메쏘드가 호출된다. 이 "
"메쏘드가 새 형을 만들고, 순서있는 딕셔너리의 키들은 ``members`` 라 불리는 어트리뷰트에 "
"저장된다."

#: ../Doc/reference/datamodel.rst:1916
msgid "Customizing instance and subclass checks"
msgstr "인스턴스 및 서브클래스 검사 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1918
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"다음 메쏘드들은 :func:`isinstance` 와 :func:`issubclass` 내장 함수들의 기본 동작을 "
"재정의하는데 사용된다."

#: ../Doc/reference/datamodel.rst:1921
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these "
"methods in order to allow the addition of Abstract Base Classes (ABCs) as"
" \"virtual base classes\" to any class or type (including built-in "
"types), including other ABCs."
msgstr ""
"특히, 메타클래스 :class:`abc.ABCMeta` 는 추상 베이스 클래스(Abstract Base Class, "
"ABC)를 다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함한다)에 \"가상 베이스 클래스"
"(virtual base class)\"로 추가할 수 있도록 하기 위해 이 메쏘드들을 구현한다."

#: ../Doc/reference/datamodel.rst:1928
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement "
"``isinstance(instance, class)``."
msgstr ""
"*instance* 가 (직접적이거나 간접적으로) *class* 의 인스턴스로 취급될 수 있으면 참을 "
"돌려준다. 만약 정의되면, ``isinstance(instance, class)`` 를 구현하기 위해 호출된다."

#: ../Doc/reference/datamodel.rst:1935
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement "
"``issubclass(subclass, class)``."
msgstr ""
"*subclass* 가 (직접적이거나 간접적으로) *class* 의 서브클래스로 취급될 수 있으면 참을 "
"돌려준다. 만약 정의되면, ``issubclass(subclass, class)`` 를 구현하기 위해 호출된다."

#: ../Doc/reference/datamodel.rst:1940
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class."
"  They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on "
"instances, only in this case the instance is itself a class."
msgstr ""
"이 메쏘드들은 클래스의 형(메타클래스)에서 조회된다는 것에 주의해야 한다. 실제 클래스에서 클래스 "
"메쏘드로 정의될 수 없다. 이 것은 인스턴스에 대해 호출되는 특수 메쏘드들의 조회와 일관성있다. 이 "
"경우 인스턴스는 클래스 자체다."

#: ../Doc/reference/datamodel.rst:1951
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 추상 베이스 클래스의 도입"

#: ../Doc/reference/datamodel.rst:1948
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality "
"in the context of adding Abstract Base Classes (see the :mod:`abc` "
"module) to the language."
msgstr ""
":meth:`~class.__instancecheck__` 와 :meth:`~class.__subclasscheck__` 를 "
"통해 :func:`isinstance` 와 :func:`issubclass` 의 동작을 커스터마이징하는데 필요한 "
"규약을 포함하는데, 이 기능의 동기는 언어에 추상 베이스 클래스 (:mod:`abc` 모듈을 보라)를 "
"추가하고자 하는데 있다."

#: ../Doc/reference/datamodel.rst:1958
msgid "Emulating callable objects"
msgstr "콜러블 객체 흉내내기"

#: ../Doc/reference/datamodel.rst:1965
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""
"인스턴스가 함수처럼 \"호출될\"때 호출된다; 이 메쏘드가 정의되면, ``x(arg1, arg2, ...)`` "
"는 ``x.__call__(arg1, arg2, ...)`` 의 줄인 표현이다."

#: ../Doc/reference/datamodel.rst:1972
msgid "Emulating container types"
msgstr "컨테이너 형 흉내내기"

#: ../Doc/reference/datamodel.rst:1974
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings "
"(like dictionaries), but can represent other containers as well.  The "
"first set of methods is used either to emulate a sequence or to emulate a"
" mapping; the difference is that for a sequence, the allowable keys "
"should be the integers *k* for which ``0 <= k < N`` where *N* is the "
"length of the sequence, or slice objects, which define a range of items."
"  It is also recommended that mappings provide the methods :meth:`keys`, "
":meth:`values`, :meth:`items`, :meth:`get`, :meth:`clear`, "
":meth:`setdefault`, :meth:`pop`, :meth:`popitem`, :meth:`!copy`, and "
":meth:`update` behaving similar to those for Python's standard dictionary"
" objects.  The :mod:`collections` module provides a "
":class:`~collections.abc.MutableMapping` abstract base class to help "
"create those methods from a base set of :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, "
":meth:`remove`, :meth:`reverse` and :meth:`sort`, like Python standard "
"list objects.  Finally, sequence types should implement addition (meaning"
" concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, "
":meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; "
"they should not define other numerical operators.  It is recommended that"
" both mappings and sequences implement the :meth:`__contains__` method to"
" allow efficient use of the ``in`` operator; for mappings, ``in`` should "
"search the mapping's keys; for sequences, it should search through the "
"values.  It is further recommended that both mappings and sequences "
"implement the :meth:`__iter__` method to allow efficient iteration "
"through the container; for mappings, :meth:`__iter__` should be the same "
"as :meth:`keys`; for sequences, it should iterate through the values."
msgstr ""
"컨테이너 객체를 구현하기 위해 다음과 같은 메쏘드들을 정의할 수 있다. 컨테이너는 보통 "
"시퀀스(리스트와 튜플 같은)나 매핑(딕셔너리 같은)이지만, 다른 컨테이너들 역시 표현할 수 있다. "
"첫번째 메쏘드 집합은 시퀀스나 매핑을 흉내내는데 사용된다; 차이점은, 시퀀스의 경우 허락되는 키는 "
"*N* 이 시퀀스의 길이일 때 ``0 <= k < N`` 를 만족하는 정수 *k* 와 항목들의 범위를 "
"정의하는 슬라이스 객체만 허락된다는 것이다. 파이썬의 표준 딕셔너리 객체와 비슷하게 동작하도록, "
"매핑에 메쏘드 :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`get`, "
":meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:`popitem`, "
":meth:`!copy`, :meth:`update` 를 제공하는 것이 좋다. :mod:`collections` "
"모듈은 :class:`~collections.abc.MutableMapping` 추상 베이스 클래스를 제공하는데, "
"기본 집합 :meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, "
":meth:`keys` 로 부터 이들 메쏘드들을 만드는데 도움을 준다. "
"파이썬의 표준 리스트 객체처럼, 가변 시퀀스는 메쏘드 :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, "
":meth:`remove`, :meth:`reverse`, :meth:`sort` 를 제공해야 한다. 마지막으로 시퀀스 "
"형은 아래에서 설명하는 메쏘드 :meth:`__add__`, :meth:`__radd__`, "
":meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__`, :meth:`__imul__` 를 "
"정의해서 더하기(이어붙이기를 뜻한다)와 곱하기(반복을 뜻한다)를 구현해야 한다. 다른 숫자 "
"연산자들은 정의하지 말아야 한다. ``in`` 연산자의 효과적인 사용을 허락하기 위해, 매핑과 시퀀스 "
"모두 :meth:`__contains__` 메쏘드를 구현하도록 권장한다. 매핑의 경우, ``in`` 은 매핑의 "
"키를 검색해야 한다; 시퀀스의 경우, 값들을 검색해야 한다. 컨테이너의 효율적인 순환(iteration)을"
" 허락하기 위해, 매핑과 시퀀스 모두 :meth:`__iter__` 메쏘드를 구현하는 것 또한 권장한다; "
"매핑의 경우, :meth:`__iter__` 는 :meth:`keys` 와 같아야 한다; 시퀀스의 경우, 값들을 "
"순환해야 한다."

#: ../Doc/reference/datamodel.rst:2009
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the"
" length of the object, an integer ``>=`` 0.  Also, an object that doesn't"
" define a :meth:`__bool__` method and whose :meth:`__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"내장함수 :func:`len` 를 구현하기 위해 호출된다. 객체의 길이를 돌려줘야 하는데, ``>=`` 0 "
"인 정수다. 또한 :meth:`__bool__` 메쏘드를 정의하지 않은 객체의 :meth:`__len__` 이 0 "
"을 돌려주면 논리 문맥에서 거짓으로 취급된다."

#: ../Doc/reference/datamodel.rst:2016
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If "
"the length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__bool__` method."
msgstr ""
"CPython 에서, 길이는 최대 :attr:`sys.maxsize` 일 것이 요구된다. 만약 길이가 "
":attr:`!sys.maxsize` 보다 크면, 어떤 기능들 (:func:`len` 과 같은)은 "
":exc:`OverflowError` 를 일으킬 수 있다. 참거짓 검사에서 :exc:`!OverflowError` 가 "
"일어나는 것을 막기위해, 객체는 :meth:`__bool__` 를 정의해야 한다."

#: ../Doc/reference/datamodel.rst:2025
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an "
"estimated length for the object (which may be greater or less than the "
"actual length). The length must be an integer ``>=`` 0. This method is "
"purely an optimization and is never required for correctness."
msgstr ""
":func:`operator.length_hint` 를 구현하기 위해 호출된다. 객체의 추정된 길이를 돌여줘야 "
"한다(실제 길이보다 크거나 작을 수 있다). 길이는 ``>=`` 0 인 정수여야 한다. 이 메쏘드는 "
"순수하게 최적화를 위한 것이고 결코 올바름이 요구되지는 않는다."

#: ../Doc/reference/datamodel.rst:2035
msgid ""
"Slicing is done exclusively with the following three methods.  A call "
"like ::"
msgstr ""
"슬라이싱은 전적으로 다음에 나오는 세 메쏘드들에의해 수행된다 ::"

#: ../Doc/reference/datamodel.rst:2039
msgid "is translated to ::"
msgstr "과 같은 호출은 ::"

#: ../Doc/reference/datamodel.rst:2043
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "로 번역되고, 다른 형태도 마찬가지다. 빠진 슬라이스 항목은 항상 ``None`` 으로 채워진다."

#: ../Doc/reference/datamodel.rst:2050
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the "
"special interpretation of negative indexes (if the class wishes to "
"emulate a sequence type) is up to the :meth:`__getitem__` method. If "
"*key* is of an inappropriate type, :exc:`TypeError` may be raised; if of "
"a value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. "
"For mapping types, if *key* is missing (not in the container), "
":exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` 의 값을 구하기 위해 호출된다. 시퀀스형의 경우, 정수와 슬라이스 객체만 키로 "
"허용된다. 음수 인덱스(만약 클래스가 시퀀스 형을 흉내내길 원한다면)의 특별한 해석은 "
":meth:`__getitem__` 메쏘드에 달려있음에 주의해야 한다. 만약 *key* 가 적절하지 않은 형인 "
"경우, :exc:`TypeError` 가 발생할 수 있다; 만약 시퀀스의 인덱스 범위를 벗어나면(음수에 대한 "
"특별한 해석 후에), :exc:`IndexError` 를 일으켜야 한다. 매핑 형의 경우, *key* 가 "
"(컨테이너에) 없으면, :exc:`KeyError` 를 일으켜야 한다."

#: ../Doc/reference/datamodel.rst:2061
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` 루프는 스퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 "
":exc:`IndexError` 가 일어날 것으로 기대하고 있다."

#: ../Doc/reference/datamodel.rst:2067
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement "
"``self[key]`` for dict subclasses when key is not in the dictionary."
msgstr ""
":class:`dict`\\ .\\ :meth:`__getitem__` 이 dict 서브클래스에서 키가 딕셔너리에 "
"없을 경우 ``self[key]`` 를 구현하기 위해 호출한다."

#: ../Doc/reference/datamodel.rst:2073
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support changes to the values for keys, or if new keys can be "
"added, or for sequences if elements can be replaced.  The same exceptions"
" should be raised for improper *key* values as for the "
":meth:`__getitem__` method."
msgstr ""
"``self[key]`` 로의 대입을 구현하기 위해 호출된다. :meth:`__getitem__` 과 같은 주의가 "
"필요하다. 매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 "
"경우는 항목이 교체될 수 있을 때만 구현되어야 한다. 잘못된 *key* 값의 경우는 "
":meth:`__getitem__` 에서와 같은 예외를 일으켜야 한다."

#: ../Doc/reference/datamodel.rst:2082
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support removal of keys, or for sequences if elements can be "
"removed from the sequence.  The same exceptions should be raised for "
"improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` 의 삭제를 구현하기 위해 호출된다. :meth:`__getitem__` 과 같은 주의가 "
"필요하다. 매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 "
"제거될 수 있을 때만 구현되어야 한다. 잘못된 *key* 값의 경우는 :meth:`__getitem__` "
"에서와 같은 예외를 일으켜야 한다."

#: ../Doc/reference/datamodel.rst:2091
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"컨테이너의 이터레이터가 필요할 때 이 메쏘드가 호출된다. 이 메쏘드는 컨테이너에 포함된 모든 "
"객체들을 탐색할 수 있는 이터레이터 객체를 돌려줘야 한다. 매핑의 경우, 컨테이너의 키를 참색해야 "
"한다."

#: ../Doc/reference/datamodel.rst:2095
msgid ""
"Iterator objects also need to implement this method; they are required to"
" return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr ""
"이터레이터 객체 역시 이 메쏘드를 구현할 필요가 있다; 자기 자신을 돌려줘야 한다. 이터레이터 "
"객체에 대한 추가의 정보는 :ref:`typeiter` 에 있다."

#: ../Doc/reference/datamodel.rst:2101
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse"
" iteration.  It should return a new iterator object that iterates over "
"all the objects in the container in reverse order."
msgstr ""
":func:`reversed` 내장 함수가 역탐색(reverse iteration)을 구현하기 위해 (있다면) "
"호출한다. 컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 한다."

#: ../Doc/reference/datamodel.rst:2105
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` "
"and :meth:`__getitem__`).  Objects that support the sequence protocol "
"should only provide :meth:`__reversed__` if they can provide an "
"implementation that is more efficient than the one provided by "
":func:`reversed`."
msgstr ""
":meth:`__reversed__` 메쏘드가 제공되지 않으면, :func:`reversed` 내장함수는 시퀀스 "
"프로토콜(:meth:`__len__` 과 :meth:`__getitem__`)을 대안으로 사용한다. 시퀀스 "
"프로토콜을 지원하는 객체들은 :func:`reversed` 가 제공하는 것 보다 더 효율적인 구현을 제공할 "
"수 있을 때만 :meth:`__reversed__` 를 제공해야 한다."

#: ../Doc/reference/datamodel.rst:2112
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, "
"container objects can supply the following special method with a more "
"efficient implementation, which also does not require the object be a "
"sequence."
msgstr ""
"멤버쉽 검사 연산자들(:keyword:`in` 과 :keyword:`not in`) 은 보통 시퀀스에 대한 "
"탐색으로 구현된다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 메쏘드를 통해 제공할 "
"수 있다. 이 경우 객체는 시퀀스일 필요도 없다."

#: ../Doc/reference/datamodel.rst:2119
msgid ""
"Called to implement membership test operators.  Should return true if "
"*item* is in *self*, false otherwise.  For mapping objects, this should "
"consider the keys of the mapping rather than the values or the key-item "
"pairs."
msgstr ""
"멤버쉽 검사 연산자를 구현하기 위해 호출된다. *item* 이 *self* 에 있으면 참을, 그렇지 않으면 "
"거짓을 돌려줘야 한다. 매핑 객체의 경우, 키-값 쌍이 아니라 매필의 키가 고려되어야 한다."

#: ../Doc/reference/datamodel.rst:2123
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence "
"iteration protocol via :meth:`__getitem__`, see :ref:`this section in the"
" language reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` 를 정의하지 않는 객체의 경우, 멤버쉽 검사는 먼저 "
":meth:`__iter__` 를 통한 탐색을 시도한 후, :meth:`__getitem__` 을 통한 낡은 시퀀스 "
"탐색 프로토콜을 시도한다. :ref:`membership-test-details` 섹션을 참고하라."

#: ../Doc/reference/datamodel.rst:2132
msgid "Emulating numeric types"
msgstr "숫자 형 흉내내기"

#: ../Doc/reference/datamodel.rst:2134
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind"
" of number implemented (e.g., bitwise operations for non-integral "
"numbers) should be left undefined."
msgstr ""
"숫자 형을 흉내내기 위해 다음과 같은 메쏘드들을 정의할 수 있다. 구현되는 특별한 종류의 숫자에의해 "
"지원되지 않는 연산들(예를들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메쏘드들을 "
"정의되지 않은 채로 남겨두어야 한다."

#: ../Doc/reference/datamodel.rst:2160
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance,"
" to evaluate the expression ``x + y``, where *x* is an instance of a "
"class that has an :meth:`__add__` method, ``x.__add__(y)`` is called.  "
"The :meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to "
"accept an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""
"이 메쏘드들은 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, "
":func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, "
"``|``)을 구현하기 위해 호출된다. 예를 들어, *x* 가 :meth:`__add__` 메쏘드를 갖고 있는 "
"클래스의 인스턴스일 때, 표현식 ``x + y`` 의 값을 구하기 위해, "
"``x.__add__(y)`` 가 호출된다.  :meth:`__divmod__` 메쏘드는 :meth:`__floordiv__`"
" 와 :meth:`__mod__` 를 사용하는 것과 동등해야 한다; :meth:`__truediv__` 와 연관되지 "
"않아야 한다; 내장 :func:`pow` 함수의 삼항 버전이 지원되기 위해서는, :meth:`__pow__` "
"메쏘드가 생략할 수 있는 세번째 인자를 받도록 정의되어야 함에 주의해야한다."

#: ../Doc/reference/datamodel.rst:2171
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""
"만약 이 메쏘드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, ``NotImplemented`` "
"를 돌려줘야 한다."

#: ../Doc/reference/datamodel.rst:2194
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of"
" different types. [#]_ For instance, to evaluate the expression ``x - "
"y``, where *y* is an instance of a class that has an :meth:`__rsub__` "
"method, ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns "
"*NotImplemented*."
msgstr ""
"이 메쏘드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, "
"``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, "
"``>>``, ``&``, ``^``, ``|``)을 구현하기 위해 호출된다. 이 함수들은 왼쪽의 피연산자가 "
"해당 연산을 지원하지 않고 [#]_, 피연산자들이 서로 다른 형일때만 호출된다. [#]_ 예를 들어, "
"표현식 ``x - y`` 의 값을 구하려고 할 때, *y* 가 :meth:`__rsub__` 를 갖는 클래스의 "
"인스턴스이고, ``x.__sub__(y)`` 가 *NotImplemented* 를 돌려주면 ``y.__rsub__(x)``"
" 가 호출된다."

#: ../Doc/reference/datamodel.rst:2205
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"삼항 :func:`pow` 는 :meth:`__rpow__` 를 호출하려고 시도하지 않음에 주의해야 한다 "
"(그렇게 하려면 변환 규칙(coercion rule)이 너무 복잡해진다)."

#: ../Doc/reference/datamodel.rst:2210
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this "
"method will be called before the left operand's non-reflected method.  "
"This behavior allows subclasses to override their ancestors' operations."
msgstr ""
"만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브클래스이고, 그 서브클래스가 연산의 뒤집힌 "
"메쏘드들 제공하면, 이 메쏘드가 왼쪽 연산자의 뒤집히지 않은 메쏘드보다 먼저 호출된다. 이 동작은 "
"서브클래스가 조상들의 연산을 재정의할 수 있도록 한다."

#: ../Doc/reference/datamodel.rst:2230
msgid ""
"These methods are called to implement the augmented arithmetic "
"assignments (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods should"
" attempt to do the operation in-place (modifying *self*) and return the "
"result (which could be, but does not have to be, *self*).  If a specific "
"method is not defined, the augmented assignment falls back to the normal "
"methods.  For instance, if *x* is an instance of a class with an "
":meth:`__iadd__` method, ``x += y`` is equivalent to ``x = "
"x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of "
"the data model."
msgstr ""
"이 메쏘드들은 증분 산술 대입(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, "
"``%=``, ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``)을 구현하기 위해 "
"호출된다. 이 메쏘드는 연산을 제자리에서(*self* 를 수정해서) 하도록 시도해야 하고, 결과(반드시 "
"그래야 하는 것은 아니지만 *self* 일 수 있다)를 돌려줘야 한다. 만약 특정 메쏘드가 정의되지 "
"않으면, 중분 대입은 알반적인 메쏘드들을 대신 사용한다. 예를 들어, *x* 가 :meth:`__iadd__`"
" 메쏘드를 갖는 클래스의 인스턴스면, ``x += y`` 는 ``x = x.__iadd__(y)`` 와 동등하다. "
"그렇지 않으면, ``x + y`` 의 값을 구할 때 처럼, ``x.__add__(y)`` 와 "
"``y.__radd__(x)`` 가 고려된다. 어떤 상황에서, 증분 대입은 예상치못한 오류로 이어질 수 "
"있다.(:ref:`faq-augmented-assignment-tuple-error` 를 보라). 하지만 이 동작은 "
"사실 데이터 모델의 일부다."

#: ../Doc/reference/datamodel.rst:2251
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr ""
"일항 산술 연산(``-``, ``+``, :func:`abs`, ``~``)을 구현하기 위해 호출된다."

#: ../Doc/reference/datamodel.rst:2266
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, "
":func:`float` and :func:`round`.  Should return a value of the "
"appropriate type."
msgstr ""
"내장 함수 :func:`complex`, :func:`int`, :func:`float`, :func:`round` 를 "
"구현하기위해 호출된다. 적절한 형의 값을 돌려줘야 한다."

#: ../Doc/reference/datamodel.rst:2273
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is "
"an integer type.  Must return an integer."
msgstr ""
":func:`operator.index` 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 "
"없이 변환해야할 때(슬라이싱이나 내장 :func:`bin`, :func:`hex`, :func:`oct` 들에서와 "
"같이)마다 호출된다. 이 메쏘드의 존재는 숫자 객체가 정수 형임을 가리킨다. 반드시 정수를 돌려줘야 "
"한다."

#: ../Doc/reference/datamodel.rst:2281
msgid ""
"In order to have a coherent integer type class, when :meth:`__index__` is"
" defined :meth:`__int__` should also be defined, and both should return "
"the same value."
msgstr ""
"일관성있는 정수형 클래스를 갖기 위해서, :meth:`__index__` 가 정의될 때는 "
":meth:`__int__` 역시 정의되어야하고, 둘 다 같은 값을 돌려줘야 한다."

#: ../Doc/reference/datamodel.rst:2289
msgid "With Statement Context Managers"
msgstr "with 문 컨텍스트 매니저"

#: ../Doc/reference/datamodel.rst:2291
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to"
" be established when executing a :keyword:`with` statement. The context "
"manager handles the entry into, and the exit from, the desired runtime "
"context for the execution of the block of code.  Context managers are "
"normally invoked using the :keyword:`with` statement (described in "
"section :ref:`with`), but can also be used by directly invoking their "
"methods."
msgstr ""
"컨텍스트 매니저(:dfn:`context manager`)는 :keyword:`with` 문을 실행할 때 자리잡는 "
"실행 컨텍스트(context)를 정의하는 객체다. 코드 블럭의 실행을 위해, 컨텍스트 매니저는 원하는 "
"실행시간 컨텍스트로의 진입과 탈출을 처리한다. 컨텍스트 매니저는 보통 :keyword:`with` "
"문(:ref:`with` 섹션에서 설명한다)으로 시작되지만, 그들의 메쏘드를 호출해서 직접적으로 사용할 "
"수도 있다."

#: ../Doc/reference/datamodel.rst:2302
msgid ""
"Typical uses of context managers include saving and restoring various "
"kinds of global state, locking and unlocking resources, closing opened "
"files, etc."
msgstr ""
"컨텍스트 매니저의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 "
"복구하는것, 자원을 로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것등이 "
"있다."

#: ../Doc/reference/datamodel.rst:2305
msgid "For more information on context managers, see :ref:`typecontextmanager`."
msgstr "컨택스트 매니저에 대한 더 자세한 정보는 :ref:`typecontextmanager` 에 나온다."

#: ../Doc/reference/datamodel.rst:2310
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified"
" in the :keyword:`as` clause of the statement, if any."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트에 진입한다. :keyword:`with` 문은 :keyword:`as` 절로 "
"지정된 대상이 있다면, 이 메쏘드의 반환값을 연결한다."

#: ../Doc/reference/datamodel.rst:2317
msgid ""
"Exit the runtime context related to this object. The parameters describe "
"the exception that caused the context to be exited. If the context was "
"exited without an exception, all three arguments will be :const:`None`."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트를 종료한다. 파라미터들은 컨텍스트에서 벗어나게 만든 예외를 "
"기술한다. 만약 컨텍스트가 예외 없이 종료한다면, 세 인자 모두 :const:`None` 이 된다."

#: ../Doc/reference/datamodel.rst:2321
msgid ""
"If an exception is supplied, and the method wishes to suppress the "
"exception (i.e., prevent it from being propagated), it should return a "
"true value. Otherwise, the exception will be processed normally upon exit"
" from this method."
msgstr ""
"만약 예외가 제공되고, 메쏘드가 예외를 중지시키고 싶으면 (즉 확산되는 것을 막으려면) 참(true)을 "
"돌려줘야 한다. 그렇지 않으면 예외는 이 메쏘드가 종료한 후에 계속 진행된다."

#: ../Doc/reference/datamodel.rst:2325
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
":meth:`__exit__` 메쏘드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 한다; 이 "
"것은 호출자(caller)의 책임이다."

#: ../Doc/reference/datamodel.rst:2332
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 문"

#: ../Doc/reference/datamodel.rst:2332
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr ""
"파이썬 :keyword:`with` 문에 대한 규격, 배경, 예."

#: ../Doc/reference/datamodel.rst:2339
msgid "Special method lookup"
msgstr "특수 메쏘드 조회"

#: ../Doc/reference/datamodel.rst:2341
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"사용자 정의 클래스의 경우, 암묵적인 특수 메쏘드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 "
"형에 정의되어 있을 때만 올바르게 동작함이 보장된다. 이런 동작은 다음과 같은 코드가 예외를 "
"일으키는 원인이다:"

#: ../Doc/reference/datamodel.rst:2356
msgid ""
"The rationale behind this behaviour lies with a number of special methods"
" such as :meth:`__hash__` and :meth:`__repr__` that are implemented by "
"all objects, including type objects. If the implicit lookup of these "
"methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"이런 동작의 배경에 깔린 논리는, 모든 객체(형 객체를 포함해서)들에 의해 구현되는 "
":meth:`__hash__` 나 :meth:`__repr__` 과 같은 많은 특수 메쏘드들과 관련이 있다. 만약 "
"이 메쏘드들에 대한 암묵적인 조회가 일반적인 조회 프로세스를 거친다면, 형 객체 자체에 대해 "
"호출되었을 때 실패하게 된다:"

#: ../Doc/reference/datamodel.rst:2369
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way"
" is sometimes referred to as 'metaclass confusion', and is avoided by "
"bypassing the instance when looking up special methods::"
msgstr ""
"클래스의 연결되지 않은 메쏘드를 호출하려는 이런 식의 잘못된 시도는 종종 '매타클래스 혼란"
"(metaclass confusion)' 이라고 불리고, 특수 메쏘드를 조회할 때 인스턴스를 우회하는 "
"방법으로 피할 수 있다."

#: ../Doc/reference/datamodel.rst:2378
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"올바름을 추구하기 위해 인스턴스 어트리뷰트들을 우회하는 것에 더해, 암묵적인 특수 메쏘드 조회는 "
"객체의 메타클래스의 :meth:`__getattribute__` 조차도 우회한다::"

#: ../Doc/reference/datamodel.rst:2404
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides"
" significant scope for speed optimisations within the interpreter, at the"
" cost of some flexibility in the handling of special methods (the special"
" method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"이런식으로 :meth:`__getattribute__` 기작을 우회하는 것은 특수 메쏘드 처리의 유연함을 "
"일부 포기하는 대신(특수 메쏘드가 인터프리터에 의해 일관성있게 호출되기 위해서는 *반드시* 클래스 "
"객체에 설정되어야 한다), 인터프리터 내부에서의 속도 최적화를 위한 상당한 기회를 제공한다."

#: ../Doc/reference/datamodel.rst:2415
msgid "Coroutines"
msgstr "코루틴(Coroutines)"

#: ../Doc/reference/datamodel.rst:2419
msgid "Awaitable Objects"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../Doc/reference/datamodel.rst:2421
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine` objects returned from :keyword:`async def` "
"functions are awaitable."
msgstr ""
"어웨이터블(:term:`awaitable`) 객체는 일반적으로 :meth:`__await__` 메쏘드를 구현한다. "
":keyword:`async def` 함수가 돌려주는 코루틴(:term:`Coroutine`) 객체는 어웨이터블이다."

#: ../Doc/reference/datamodel.rst:2427
msgid ""
"The :term:`generator iterator` objects returned from generators decorated"
" with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""
":func:`types.coroutine` 이나 :func:`asyncio.coroutine` 로 데코레이션된 "
"제너레이터가 돌려주는 제너레이터 이터레이터(:term:`generator iterator`) 객체 또한 "
"어웨이터블이지만 :meth:`__await__` 를 구현하지 않는다."

#: ../Doc/reference/datamodel.rst:2433
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` "
"implements this method to be compatible with the :keyword:`await` "
"expression."
msgstr ""
"이터레이터(:term:`iterator`)를 돌려줘야 한다. 어웨이터블(:term:`awaitable`) 객체를 "
"구현하기 위해 사용되어야 한다. 예를 들어, :class:`asyncio.Future` 는 "
":keyword:`await` 표현식과 호환되기 위해 이 메쏘드를 구현한다."

#: ../Doc/reference/datamodel.rst:2439
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있다."

#: ../Doc/reference/datamodel.rst:2445
msgid "Coroutine Objects"
msgstr "코루틴 객체(Coroutine Objects)"

#: ../Doc/reference/datamodel.rst:2447
msgid ""
":term:`Coroutine` objects are :term:`awaitable` objects. A coroutine's "
"execution can be controlled by calling :meth:`__await__` and iterating "
"over the result.  When the coroutine has finished executing and returns, "
"the iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  "
"Coroutines should not directly raise unhandled :exc:`StopIteration` "
"exceptions."
msgstr ""
"코루틴(:term:`Coroutine`) 객체는 어웨이터블(:term:`awaitable`) 객체다. 코루틴의 실행은 :meth:`__await__`"
" 를 호출하고 그 결과를 탐색하는 방법으로 제어될 수 있다. 코루틴이 실행을 완료하고 복귀할 때, "
"이터레이터는 :exc:`StopIteration` 을 일으키고, 예외의 :attr:`~StopIteration.value`"
" 어트리뷰트가 반환 값을 갖고 있다. 만약 코루틴이 예외를 일으키면, 이터레이터에 의해 확산된다. "
"코루틴이 직접 잡히지 않은 :exc:`StopIteration` 예외를 일으키지는 말아야 한다."

#: ../Doc/reference/datamodel.rst:2455
msgid ""
"Coroutines also have the methods listed below, which are analogous to "
"those of generators (see :ref:`generator-methods`).  However, unlike "
"generators, coroutines do not directly support iteration."
msgstr ""
"코루틴은 다음에 나열하는 메쏘드들 또한 갖고 있는데, 제너레이터(:ref:`generator-methods` "
"를 보라)의 것들과 닮았다. 하지만, 제너레이터와는 달리, 코루틴은 탐색을 직접적으로 지원하지는 "
"않는다."

#: ../Doc/reference/datamodel.rst:2459
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "코루틴을 두 번 await 하면 :exc:`RuntimeError` 를 일으킨다."

#: ../Doc/reference/datamodel.rst:2465
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, "
"this is equivalent to advancing the iterator returned by "
":meth:`__await__`.  If *value* is not ``None``, this method delegates to "
"the :meth:`~generator.send` method of the iterator that caused the "
"coroutine to suspend.  The result (return value, :exc:`StopIteration`, or"
" other exception) is the same as when iterating over the "
":meth:`__await__` return value, described above."
msgstr ""
"코루틴의 실행을 시작하거나 재시작한다. *value* 가 ``None`` 이면, :meth:`__await__` "
"가 돌려준 이터레이터를 전진시키는 것과 같다. *value* 가 ``None`` 이 아니면, 이 메쏘드는 "
"코루틴이 일시중지되도록 한 이터레이터의 :meth:`~generator.send` 메쏘드로 위임한다. "
"결과(반환값, :exc:`StopIteration` 이나 다른 예외)는 위에서 설명한 :meth:`__await__` "
"의 반환 값을 탐색할 때와 같다."

#: ../Doc/reference/datamodel.rst:2475
msgid ""
"Raises the specified exception in the coroutine.  This method delegates "
"to the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception "
"is raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating "
"over the :meth:`__await__` return value, described above.  If the "
"exception is not caught in the coroutine, it propagates back to the "
"caller."
msgstr ""
"코루틴에서 지정한 예외가 발생하도록 한다. 이 메쏘드는 코루틴이 일시중지되도록 한 이터레이터의 "
":meth:`~generator.throw` 메쏘드로 위임한다(그런 메쏘드를 가지는 경우). 그렇지 않으면, "
"일시중지지점에서 예외가 발생한다. 결과(반환값, :exc:`StopIteration` 이나 다른 예외)는 "
"위에서 설명한 :meth:`__await__` 의 반환 값을 탐색할 때와 같다. 만약 예외가 코루틴에서 "
"잡히지 않는다면 호출자에게 되돌아 전파된다."

#: ../Doc/reference/datamodel.rst:2486
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has "
"such a method.  Then it raises :exc:`GeneratorExit` at the suspension "
"point, causing the coroutine to immediately clean itself up. Finally, the"
" coroutine is marked as having finished executing, even if it was never "
"started."
msgstr ""
"코루틴이 스스로를 정리하고 종료하도록 만든다. 만약 코루틴이 일시중지중이면, 이 메쏘드는 먼저 "
"코루틴이 일시정지되도록 한 이터레이터의 :meth:`~generator.close` 메쏘드로 위임한다(그런 "
"메쏘드를 가지는 경우). 그런 다음 일시중지지점에서 :exc:`GeneratorExit` 를 발생시키는데, "
"코루틴이 즉시 자신을 정리하도록 만든다. 마지막으로 코루틴에 실행을 종료했다고 표시하는데, 아직 "
"시작하지 조차 않았을 때도 그렇다."

#: ../Doc/reference/datamodel.rst:2494
msgid ""
"Coroutine objects are automatically closed using the above process when "
"they are about to be destroyed."
msgstr ""
"코루틴 객체가 파괴될 때는 위의 프로세스에따라 자동적으로 닫힌다(closed)."

#: ../Doc/reference/datamodel.rst:2500
msgid "Asynchronous Iterators"
msgstr "비동기 이터레이터(Asynchronous Iterators)"

#: ../Doc/reference/datamodel.rst:2502
msgid ""
"An *asynchronous iterable* is able to call asynchronous code in its "
"``__aiter__`` implementation, and an *asynchronous iterator* can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
"*비동기 이터러블(asynchronous iterable)* 은 자신의 ``__aiter__`` 구현에서 비동기 코드를 호출할 수 있고, *비동기 이터레이터* 는 자신의 ``__anext__`` 메쏘드에서 비동기 코드를 호출할 수 있다."

#: ../Doc/reference/datamodel.rst:2506
msgid "Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"비동기 이터레이터는 :keyword:`async for` 문에서 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:2510
msgid "Must return an *asynchronous iterator* object."
msgstr "*비동기 이터레이터* 객체를 돌려줘야 한다."

#: ../Doc/reference/datamodel.rst:2514
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is "
"over."
msgstr ""
"이터레이터의 다음 값을 주는 *어웨이터블* 을 돌려줘야 한다. 탐색이 끝나면 "
":exc:`StopAsyncIteration` 를 일으켜야한다."

#: ../Doc/reference/datamodel.rst:2517
msgid "An example of an asynchronous iterable object::"
msgstr "비동기 이터러블 객체의 예::"

#: ../Doc/reference/datamodel.rst:2536
msgid ""
"Starting with CPython 3.5.2, ``__aiter__`` can directly return "
":term:`asynchronous iterators <asynchronous iterator>`.  Returning an "
":term:`awaitable` object will result in a "
":exc:`PendingDeprecationWarning`."
msgstr ""
"CPython 3.5.2 부터, ``__aiter__`` 는 :term:`비동기 이터레이터 <asynchronous "
"iterator>` 를 직접 돌려줄 수 있다. 어웨이터블(:term:`awaitable`) 객체를 돌려주면 "
":exc:`PendingDeprecationWarning` 이 발생한다."

#: ../Doc/reference/datamodel.rst:2542
msgid ""
"The recommended way of writing backwards compatible code in CPython 3.5.x"
" is to continue returning awaitables from ``__aiter__``.  If you want to "
"avoid the PendingDeprecationWarning and keep the code backwards "
"compatible, the following decorator can be used::"
msgstr ""
"CPython 3.5.x 와의 과거 호환성을 유지하는 코드들 작성을 위해 권장하는 방법은 "
"``__aiter__`` 에서 계속 어웨이터블을 돌려주는 것이다. 만약 PendingDeprecationWarning"
" 를 피하면서 과거 호환성을 유지하고 싶다면, 다음과 같은 데코레이터를 사용할 수 있다::"

#: ../Doc/reference/datamodel.rst:2561
msgid "Example::"
msgstr "예::"

#: ../Doc/reference/datamodel.rst:2572
msgid ""
"Starting with CPython 3.6, the :exc:`PendingDeprecationWarning` will be "
"replaced with the :exc:`DeprecationWarning`. In CPython 3.7, returning an"
" awaitable from ``__aiter__`` will result in a :exc:`RuntimeError`."
msgstr ""
"CPython 3.6 부터, :exc:`PendingDeprecationWarning` 은 :exc:`DeprecationWarning` 으로 변경되었다. CPython 3.7 부터, ``__aiter__`` 이 어웨이터블을 돌려주면 :exc:`RuntimeError` 을 일으킬 것이다."

#: ../Doc/reference/datamodel.rst:2579
msgid "Asynchronous Context Managers"
msgstr "비동기 컨텍스트 매니저(Asynchronous Context Managers)"

#: ../Doc/reference/datamodel.rst:2581
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*비동기 컨택스트 매니저(asynchronous context manager)* 는 ``__aenter__`` 와 "
"``__aexit__`` 메쏘드에서 실행을 일시중지할 수 있는 *컨택스트 매니저* 다."

#: ../Doc/reference/datamodel.rst:2584
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"비동기 컨택스트 매니저는 :keyword:`async with` 문에서 사용될 수 있다."

#: ../Doc/reference/datamodel.rst:2588
msgid ""
"This method is semantically similar to the :meth:`__enter__`, with only "
"difference that it must return an *awaitable*."
msgstr ""
"이 메쏘드는 :meth:`__enter__` 메쏘드와 의미적으로 유사한데, 유일한 차이점은 *어웨이터블* "
"을 돌려줘야 한다는 것이다."

#: ../Doc/reference/datamodel.rst:2593
msgid ""
"This method is semantically similar to the :meth:`__exit__`, with only "
"difference that it must return an *awaitable*."
msgstr ""
"이 메쏘드는 :meth:`__exit__` 메쏘드와 의미적으로 유사한데, 유일한 차이점은 *어웨이터블* 을 "
"돌려줘야 한다는 것이다."

#: ../Doc/reference/datamodel.rst:2596
msgid "An example of an asynchronous context manager class::"
msgstr "비동기 컨택스트 매니저의 예::"

#: ../Doc/reference/datamodel.rst:2609
msgid "Footnotes"
msgstr "각"

#: ../Doc/reference/datamodel.rst:2610
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it "
"can lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"어떤 제한된 조건하에서, 어떤 경우에 객체의 형을 변경하는 것이 *가능하다*. 하지만 잘못 다뤄질 경우 아주 괴상한 결과로 이어질 수 있기 때문에 일반적으로 좋은 생각이 아니다."

#: ../Doc/reference/datamodel.rst:2614
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and "
":meth:`__contains__` methods have special handling for this; others will "
"still raise a :exc:`TypeError`, but may do so by relying on the behavior "
"that ``None`` is not callable."
msgstr ""
":meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, "
":meth:`__contains__` 가 이런 경우에 대한 특별한 처리를 포함하고 있다; 다른 것들도 여전히 "
":exc:`TypeError` 을 일으키지만, 단지 ``None`` 이 콜러블이 아니기 때문에 그런 것 뿐이다."

#: ../Doc/reference/datamodel.rst:2619
msgid ""
"\"Does not support\" here means that the class has no such method, or the"
" method returns ``NotImplemented``.  Do not set the method to ``None`` if"
" you want to force fallback to the right operand's reflected method—that "
"will instead have the opposite effect of explicitly *blocking* such "
"fallback."
msgstr ""
"여기서 \"지원하지 않는다\" 는 클래스가 그런 메쏘드를 갖지 않거나, 메쏘드가 "
"``NotImplemented`` 를 돌려줌을 뜻한다. 오른쪽 피연산자의 뒤집힌 메쏘드를 사용하는 대안이 "
"시도도도록 하려면 메쏘드를 ``None`` 으로 설정하지 말아야 한다 - 그렇게 하는 것은 그런 대안을 "
"명시적으로 금지하는 반대 효과를 준다."

#: ../Doc/reference/datamodel.rst:2625
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, "
"which is why the reflected method is not called."
msgstr ""
"피연산자들이 같은 형인 경우, 뒤집히지 않은 메쏘드(:meth:`__add__` 같은)가 실패하면 그 "
"연산이 지원되지 않는 것으로 간주된다. 이 것이 뒤집힌 메쏘드가 호출되지 않는 이유다."

